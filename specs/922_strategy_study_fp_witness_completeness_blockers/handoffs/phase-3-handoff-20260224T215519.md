# Phase 3 Handoff: Int Embedding via OrderIso

**Task**: 922 - strategy_study_fp_witness_completeness_blockers
**Phase**: 3 - Int Embedding via OrderIso
**Session**: sess_1771969092_eaf615
**Date**: 2026-02-24
**Status**: PARTIAL - infrastructure built, blocker identified

## Immediate Next Action

Resolve the CanonicalR antisymmetry question: does `CanonicalR M₁ M₂ ∧ CanonicalR M₂ M₁` imply `M₁ = M₂` for the reachable fragment? This is the key blocker for constructing a LinearOrder on `CanonicalReachable`. Three paths forward:

1. **Prove antisymmetry** using the temp_linearity axiom. The linearity three-way disjunction (F(phi∧neg(phi)) ∨ F(phi∧F(neg(phi))) ∨ F(F(phi)∧neg(phi))) produces contradictions in Case 1 and in the equality sub-cases (W = M₁ or W' = M₂) of Cases 2 and 3. The remaining sub-cases (CanonicalR between witnesses and original MCSes) need further analysis.

2. **Quotient by mutual CanonicalR** to get a true linear order. Define equivalence classes of mutually CanonicalR-related MCSes and work with the quotient type. This avoids the antisymmetry question but adds complexity.

3. **Bypass OrderIso entirely**: Build BFMCS Int directly by an explicit chain construction, using canonical_forward_F for witnesses. This avoids needing any order structure on the reachable fragment.

## Current State

### File: `Theories/Bimodal/Metalogic/Bundle/CanonicalReachable.lean`
- **Status**: Builds with zero sorries, zero errors
- **Contents**: CanonicalReachable type definition with:
  - `CanonicalReachable` structure (world, is_mcs, reachable)
  - `CanonicalReachable.root`, `Nonempty` instance
  - `canonical_reachable_comparable` (total preorder)
  - `canonical_forward_F_strict`, `canonical_backward_P_strict` (strict successor/predecessor construction)
  - `gcontent_eq_of_mutual_R` (GContent equality for mutual CanonicalR)
  - Various temporal duality helpers
  - `conj_neg_derives_bot`, `F_conj_neg_not_in_mcs` (inconsistency lemmas)

### File: `specs/922_*/plans/implementation-002.md`
- Phase 3 marked [PARTIAL]
- Progress section added with all lemmas listed

## Key Decisions Made

1. **CanonicalR is NOT antisymmetric in general**: Two distinct MCSes can be mutually CanonicalR-related. This was discovered through careful case analysis of the linearity axiom's three-way disjunction.

2. **GContent equality follows from mutual CanonicalR**: If CanonicalR M₁ M₂ and CanonicalR M₂ M₁, then GContent(M₁) = GContent(M₂) (using temp_4: G(phi) → G(G(phi))).

3. **Strict successors require non-saturation**: A strictly distinct canonical successor exists iff the MCS is NOT temporally forward-saturated (i.e., there exists F(phi) ∈ M with phi ∉ M). This is captured by `canonical_forward_F_strict`.

## What NOT to Try

1. **Direct proof that CanonicalR is a partial order** without the linearity axiom. The counterexample in `LinearityDerivedFacts.lean` (3-point branching frame) shows CanonicalR is NOT a partial order without linearity.

2. **Using `SuccOrder.ofLinearWellFoundedLT`** to get SuccOrder. The canonical frame's reachable fragment is likely DENSE (not discrete), so WellFoundedLT would fail and SuccOrder in the Mathlib sense cannot be defined.

3. **Assuming the reachable fragment has no max/min** without proof. Temporally forward-saturated MCSes exist and are fixed points of CanonicalR. The NoMaxOrder claim requires careful argument (possibly by excluding saturated MCSes or proving they don't exist in the reachable fragment of a non-trivial root).

## Critical Context

1. The completeness chain goes: `fully_saturated_bmcs_exists_int` (sorry) → `construct_saturated_bmcs_int` → `bmcs_representation` → `bmcs_weak_completeness` + `bmcs_strong_completeness`. Phase 3-5 aim to eliminate the sorry in `fully_saturated_bmcs_exists_int`.

2. The BFMCS structure requires `D : Type*` with `[AddCommGroup D] [LinearOrder D] [IsOrderedAddMonoid D]`. Only `D = Int` is used downstream.

3. `orderIsoIntOfLinearSuccPredArch` requires: LinearOrder, SuccOrder, PredOrder, IsSuccArchimedean, NoMaxOrder, NoMinOrder, Nonempty. The first prerequisite (LinearOrder) is blocked by the antisymmetry question.

4. Alternative Mathlib path: `Order.iso_of_countable_dense` gives OrderIso between any two countable dense linear orders without max/min. But this embeds into Q (dense), not Int (discrete).

5. The `canonical_reachable_linear` theorem from Task 923 gives a NON-EXCLUSIVE three-way disjunction. It is consistent with both CanonicalR directions holding simultaneously for distinct MCSes.

## References

- Plan: `specs/922_strategy_study_fp_witness_completeness_blockers/plans/implementation-002.md`
- Research: `specs/922_strategy_study_fp_witness_completeness_blockers/reports/research-003.md`
- Code: `Theories/Bimodal/Metalogic/Bundle/CanonicalReachable.lean`
- Code: `Theories/Bimodal/Metalogic/Bundle/CanonicalFrame.lean`
- Code: `Theories/Bimodal/Metalogic/Bundle/CanonicalEmbedding.lean`
