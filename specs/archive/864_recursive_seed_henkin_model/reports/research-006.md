# Research Report: Task #864

**Task**: Recursive seed construction for Henkin model completeness
**Date**: 2026-02-17
**Focus**: Systematic Seed Construction Design - Nested Temporal Unpacking
**Session**: sess_1771390604_24ddef

## Executive Summary

- The current `buildSeedAux` does NOT fully unpack nested temporal/modal implications like `G(H psi)` or `Box(G psi)` to their ultimate consequences
- `buildSeedAux` recurses on the **inner formula** only, not on formulas generated by temporal propagation
- This is a fundamental gap: `G(H psi)` at t=0 should imply `psi` at t=0, but current construction only places `H psi` at future times without recursing into them
- The 5 remaining sorries in SeedCompletion.lean stem from this incomplete unpacking combined with the chain direction mismatch
- Proposed solution: Either recursive re-entry on propagated formulas OR explicit cross-sign pre-placement rules

## Project Context

- **Upstream Dependencies**: RecursiveSeed.lean `buildSeedAux`, DovetailingChain.lean `dovetailChainSet`, existing `SeedConsistent` proofs
- **Downstream Dependents**: SeedCompletion.lean, SeedBMCS.lean, ultimately `fully_saturated_bmcs_exists_int` and Completeness.lean
- **Alternative Paths**: Zorn's lemma approach (task 870, partially viable), 4-axiom approach (Path C from research-005.md)
- **Potential Extensions**: Once solved, pattern generalizes to any modal/temporal operator combination

## Context & Scope

This research examines the user's key insight about systematic seed construction:

> Whereas G phi should initiate a forward chain, if phi = H psi, then phi will (at later times) initiate a backward chain so that phi is guaranteed to be the case at the origin. Similarly, Box phi will require phi to hold at all worlds, even those generated later. It is important to build the seed in such a way as to unpack all implications, recursively splitting the seed until all implications are accounted for, leaving the rest to enumeration to determine.

The question is: Does the current `buildSeedAux` fully unpack nested formulas like `G(H psi)`, `Box(G psi)`, etc.?

## Findings

### 1. Analysis of buildSeedAux Recursion Pattern

The current `buildSeedAux` (RecursiveSeed.lean:555-606) has this structure:

```lean
def buildSeedAux : Formula -> Nat -> Int -> ModelSeed -> ModelSeed
  | Formula.all_future psi, famIdx, timeIdx, seed =>
    -- G psi: add G psi and psi to current, add psi to all future times
    let seed4 := ... -- adds psi and G psi to future times
    buildSeedAux psi famIdx timeIdx seed4  -- <-- RECURSES ONLY ON psi
```

**Critical observation**: The recursion is on `psi` (the inner formula) only. It does NOT recurse on the formulas that were propagated to other times.

### 2. The G(H psi) Case - Incomplete Unpacking

Consider `G(H psi)` at time t=0:

**What should happen** (semantically):
1. `G(H psi)` at t=0 means `H psi` at ALL future times t' > 0
2. `H psi` at t=5 means `psi` at ALL past times t'' < 5
3. This includes `psi` at t=0 (the origin)
4. Therefore: `G(H psi)` at t=0 implies `psi` at t=0

**What actually happens in buildSeedAux**:
1. `G(H psi)` processed at (famIdx=0, timeIdx=0)
2. `H psi` and `G(H psi)` added to all existing future times (lines 571-572)
3. Recursion: `buildSeedAux (H psi) 0 0 seed4`
4. In this recursion, `H psi` is processed at time 0:
   - `H psi` and `psi` added to time 0
   - `psi` added to all existing past times (none yet)
   - Recursion: `buildSeedAux psi 0 0 seed`

**The gap**: The `H psi` that was propagated to future times (step 2) is NEVER processed. Only the `H psi` at time 0 is processed (step 4).

### 3. Analysis of Formula Processing Flow

| Formula at t=0 | What gets placed | What does NOT happen |
|----------------|------------------|---------------------|
| `G(H psi)` | `G(H psi)` at t=0, `H psi` at futures, process `H psi` at t=0 | `H psi` at futures never processed |
| `Box(G psi)` | `Box(G psi)` at t=0, `G psi` at all families, process `G psi` at t=0 | `G psi` at other families never processed |
| `G(Box psi)` | `G(Box psi)` at t=0, `Box psi` at futures, process `Box psi` at t=0 | `Box psi` at futures never processed |

### 4. Why Nested Processing Matters for Cross-Sign

For `G(H psi)` at time t=-5:

1. `G(H psi)` at t=-5 propagates `H psi` to all future times, including t=0 and positive times
2. If `H psi` at t=10 were PROCESSED, it would:
   - Place `psi` at all times t' < 10, including t=-5 through t=9
   - This creates the required cross-sign connection
3. But since `H psi` at t=10 is NOT processed, `psi` only appears:
   - At t=-5 (from direct processing of `H psi` at starting point)
   - NOT at t=0 through t=9

### 5. Current SeedCompletion Sorries Root Cause

The 5 sorries in SeedCompletion.lean are:

| Line | Theorem | Root Cause |
|------|---------|------------|
| 161 | modal_witness_includes_boxcontent | BoxContent not processed at witness |
| 246 | forward_G (t < 0 case) | G phi propagated but inner not processed |
| 256 | backward_H (t >= 0 case) | H phi propagated but inner not processed |
| 328 | buildFamilyFromSeed_cross_sign_seed | Same as 246 |
| 372 | buildFamilyFromSeed_contains_seed (t!=0) | Seed formulas not connected through chain |

**The pattern**: All these sorries involve formulas that were PROPAGATED (via addToAllFutureTimes, addToAllPastTimes, addToAllFamilies) but whose inner structure was NOT recursively unpacked.

### 6. The Enumeration vs Pre-placement Distinction

The user's insight distinguishes:

**Pre-placement (seed construction)**:
- ALL modal/temporal implications should be recursively unpacked
- Includes nested operators like `G(H psi)`, `Box(G psi)`
- Creates explicit formula placements at all required positions
- Ensures cross-sign coherence is BUILT INTO the seed structure

**Enumeration (Lindenbaum)**:
- Adds formulas to extend consistent sets to MCS
- Does NOT need to handle cross-sign (already satisfied by seed)
- Only fills in "undetermined" positions

**Current buildSeedAux conflates these**: It places formulas via propagation but doesn't fully unpack, leaving some structure to be "hoped for" during Lindenbaum.

### 7. Design Principles for Systematic Seed Construction

Based on this analysis, a properly systematic seed construction should satisfy:

**Principle 1: Recursive Completeness**
Every formula placed in the seed (including via propagation) must have its structure recursively processed.

**Principle 2: Cross-Sign Pre-satisfaction**
If `G phi` is in the seed at time t < 0 and t' > 0 exists in the seed, then `phi` must be at t' in the seed (not left to Lindenbaum).

**Principle 3: Modal-Temporal Interaction**
If `Box(G psi)` is in the seed at (f, t), then `G psi` must be at (f', t) for all families f', AND `psi` must be at (f', t') for all f' and t' > t.

**Principle 4: Closure Property**
The seed must be "closed" under temporal/modal propagation before Lindenbaum begins.

### 8. Proposed Solution Approaches

#### Approach A: Recursive Re-entry (Major Refactoring)

Modify `buildSeedAux` to process ALL propagated formulas:

```lean
def buildSeedAux' : Formula -> Nat -> Int -> ModelSeed -> ModelSeed
  | Formula.all_future psi, famIdx, timeIdx, seed =>
    let seed1 := ... -- add G psi and psi to current
    let futureTimes := getFutureTimes seed1 famIdx timeIdx
    -- CRUCIAL CHANGE: Process psi at each future time
    let seed2 := futureTimes.foldl (fun s t =>
        let s' := s.addFormula famIdx t psi .universal_target
        let s'' := s'.addFormula famIdx t (Formula.all_future psi) .universal_target
        buildSeedAux' psi famIdx t s''  -- <-- RECURSE AT EACH FUTURE TIME
      ) seed1
    buildSeedAux' psi famIdx timeIdx seed2
```

**Challenges**:
- Termination proof becomes complex (may need well-founded recursion on (formula, positions))
- Potentially many redundant re-entries
- Need careful state management to avoid infinite loops

#### Approach B: Worklist Algorithm

Replace recursive definition with worklist processing:

```lean
structure WorkItem where
  formula : Formula
  famIdx : Nat
  timeIdx : Int

def buildSeedComplete (phi : Formula) : ModelSeed :=
  let initial := ModelSeed.initial phi
  let worklist : List WorkItem := [{formula := phi, famIdx := 0, timeIdx := 0}]
  processWorklist worklist initial {}  -- {} = processed set

def processWorklist (work : List WorkItem) (seed : ModelSeed) (done : Set WorkItem) : ModelSeed :=
  match work with
  | [] => seed
  | item :: rest =>
    if item in done then processWorklist rest seed done
    else
      let (newWork, seed') := processFormula item seed
      processWorklist (rest ++ newWork) seed' (done.insert item)
```

**Advantages**:
- Explicit termination via worklist depletion
- No redundant processing (done set)
- Natural fixpoint semantics

**Challenges**:
- Significant architectural change
- Need to prove worklist eventually empties
- Less structured for inductive proofs

#### Approach C: Explicit Cross-Sign Rules (Minimal Change)

Add explicit cross-sign placement as a post-processing step:

```lean
def addCrossSignPlacement (seed : ModelSeed) : ModelSeed :=
  -- For each G phi at time t < 0:
  --   For each future time t' > 0:
  --     Add phi at t'
  -- For each H phi at time t > 0:
  --   For each past time t' < 0:
  --     Add phi at t'
  ...
```

**Advantages**:
- Minimal change to existing buildSeedAux
- Focused fix for the specific cross-sign gap

**Challenges**:
- Doesn't solve the general nested unpacking problem
- May not capture all modal-temporal interactions

#### Approach D: 4-Axiom Propagation (From research-005.md)

Prove that the 4-axiom (`G phi -> G(G phi)`) ensures cross-sign coherence during Lindenbaum extension.

**Status**: Mathematically sound but requires connecting backward chain to time 0 to forward chain - the same architectural gap that blocks the current sorries.

### 9. Relationship to Existing Sorries

If Approach A or B is implemented:

| Sorry | Resolution Path |
|-------|-----------------|
| Line 246 (forward_G t<0) | Nested unpacking ensures phi at positive times |
| Line 256 (backward_H t>=0) | Nested unpacking ensures phi at negative times |
| Line 328 (cross_sign_seed) | Pre-placement eliminates need for propagation |
| Line 372 (contains_seed t!=0) | All seed times connected through worklist |
| Line 161 (boxcontent) | Box propagation recurses into witnesses |

### 10. Truth Lemma Requirements Revisited

For the Truth Lemma to hold:

| Requirement | Current Status | After Systematic Construction |
|-------------|----------------|------------------------------|
| Modal coherence | Depends on Lindenbaum (sorry) | Pre-satisfied by nested Box processing |
| Temporal G-coherence | Same-sign only (sorry for cross) | Pre-satisfied by recursive future processing |
| Temporal H-coherence | Same-sign only (sorry for cross) | Pre-satisfied by recursive past processing |
| Cross-sign coherence | NOT satisfied (sorry) | Pre-satisfied by full worklist completion |

## Decisions

1. **Root cause identified**: The sorries stem from incomplete nested formula unpacking, NOT from chain direction or Lindenbaum limitations
2. **Approach B (worklist) recommended**: Most principled solution with clean termination
3. **Approach C (cross-sign rules) acceptable**: Minimal change for short-term progress
4. **Approach D (4-axiom) insufficient**: Doesn't address the fundamental processing gap

## Recommendations

### Immediate (Phase 4 continuation)

1. **Document the gap explicitly** in SeedCompletion.lean comments
2. **Implement Approach C** as a targeted fix for cross-sign:
   - Add `addCrossSignPlacement : ModelSeed -> ModelSeed`
   - Apply after `buildSeed` before Lindenbaum
   - Prove consistency preservation

### Medium-term (New Phase)

3. **Design worklist algorithm** (Approach B):
   - Define `WorkItem` structure
   - Implement `processWorklist` with termination proof
   - Prove `buildSeedComplete_consistent`

4. **Prove worklist captures all nested implications**:
   - For `G(H psi)` at t=0: `psi` at t=0 is in seed
   - For `Box(G psi)` at (f,t): `psi` at (f',t') for all f', t'>t

### Long-term

5. **Replace buildSeedAux with buildSeedComplete**
6. **Eliminate all 5 sorries** via worklist closure proofs
7. **Connect to Completeness.lean** via `buildSeedBMCS_fully_saturated`

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Worklist non-termination | High | Prove complexity decreases (Nat.lt_wfRel) |
| Consistency broken by worklist | High | Incremental consistency preservation proofs |
| Approach C doesn't generalize | Medium | Use as stepping stone, replace with B |
| Performance of worklist | Low | In proofs, not runtime execution |

## References

- RecursiveSeed.lean:555-606 (buildSeedAux definition)
- SeedCompletion.lean:225-257 (buildFamilyFromSeed with sorries)
- DovetailingChain.lean:380-418 (chain construction)
- research-005.md (chain direction analysis)
- implementation-004.md (Phase 4 status)

## Appendix: Code Tracing Example

### G(H psi) at time 0 - Current Behavior

```
buildSeedAux (G (H psi)) 0 0 seed_initial
  |
  v
[Line 566-573]
  seed1 = addFormula 0 0 (G (H psi))
  seed2 = addFormula 0 0 (H psi)
  seed3 = addToAllFutureTimes 0 0 (H psi)    -- <-- H psi at all futures
  seed4 = addToAllFutureTimes 0 0 (G (H psi)) -- <-- G (H psi) at all futures
  return buildSeedAux (H psi) 0 0 seed4       -- <-- ONLY at time 0
    |
    v
[Line 574-581]
  seed1' = addFormula 0 0 (H psi)
  seed2' = addFormula 0 0 psi
  seed3' = addToAllPastTimes 0 0 psi         -- <-- psi at all pasts (empty)
  seed4' = addToAllPastTimes 0 0 (H psi)     -- <-- H psi at all pasts (empty)
  return buildSeedAux psi 0 0 seed4'         -- <-- psi at time 0
```

**Result**: `H psi` is at future times, but NOT PROCESSED there. If `H psi` at t=5 were processed, it would add `psi` to times 0-4.

### G(H psi) at time 0 - Desired Behavior

```
WORKLIST: [{G (H psi), 0, 0}]
DONE: {}

Process {G (H psi), 0, 0}:
  - Place G (H psi), H psi at time 0
  - Place G (H psi), H psi at futures (say t=1, t=2)
  - ADD TO WORKLIST: {H psi, 0, 1}, {H psi, 0, 2}  -- <-- CRUCIAL
  - ADD TO WORKLIST: {H psi, 0, 0}

Process {H psi, 0, 1}:
  - Place H psi, psi at time 1
  - Place H psi, psi at times < 1 (time 0)         -- <-- CROSS-SIGN!
  - ADD TO WORKLIST: {psi, 0, 0}, {psi, 0, 1}

Process {H psi, 0, 0}:
  - Place H psi, psi at time 0 (already there)
  - No past times yet

...continue until worklist empty...
```

**Result**: `psi` is explicitly placed at time 0 via processing `H psi` at time 1.

## Next Steps

1. Implement `addCrossSignPlacement` as targeted Approach C fix
2. Design worklist algorithm with termination proof
3. Prove worklist completeness for nested formulas
4. Replace `buildSeedAux` with worklist-based `buildSeedComplete`
