\documentclass[../LogosReference.tex]{subfiles}
\begin{document}

% ============================================================================
% Section: Core Extension Semantics
% ============================================================================

\section{Core Extension: Semantic Framework}\label{sec:core-semantics}

% ------------------------------------------------------------
% Core Frame
% ------------------------------------------------------------

\subsection{Core Frame}\label{sec:core-frame}

\begin{definition}[Core Frame]\label{def:core-frame}
A \emph{core frame} is a structure $\mframe = \langle \statespace, \parthood, \temporalorder, \taskrel \rangle$ where:
\begin{itemize}
  \item $\langle \statespace, \parthood \rangle$ is a constitutive frame
  \item $\temporalorder = \langle D, +, \leq \rangle$ is a totally ordered abelian group
  \item $\taskrel$ is a ternary relation on $\statespace \times D \times \statespace$ satisfying the constraints below
\end{itemize}
\end{definition}

\begin{notation}
We write $\task{s}{d}{t}$ to denote that $(s, d, t) \in \taskrel$, read ``there is a task from $s$ to $t$ of duration $d$.''
\end{notation}

% ------------------------------------------------------------
% State Modality Definitions
% ------------------------------------------------------------

\subsection{State Modality Definitions}\label{sec:state-modality}

\begin{definition}[State Modality]\label{def:state-modality}
Let $\mframe = \langle \statespace, \parthood, \temporalorder, \taskrel \rangle$ be a core frame.
\begin{align}
s \in \possible &\iff \task{s}{0}{s} && \text{(Possible state)} \\
s \notin \possible &\iff \neg(\task{s}{0}{s}) && \text{(Impossible state)} \\
s \connected t &\iff \task{s}{d}{t} \text{ or } \task{t}{d}{s} \text{ for some } d && \text{(Connected states)} \\
s \compatible t &\iff \fusion{s}{t} \in \possible && \text{(Compatible states)} \\
w \in \worldstates &\iff w \text{ is a maximal possible state} && \text{(World-state)} \\
s \in \necessary &\iff s \connected t \text{ implies } s = t && \text{(Necessary state)}
\end{align}
\end{definition}

\begin{definition}[Maximal Compatible Part]\label{def:maximal-compatible}
The set of \emph{maximal $t$-compatible parts} of $r$ is:
\[
\maxcompat{r}{t} := \{s : s \parthood r, s \compatible t, \text{ and } s' \parthood s \text{ for all } s' \text{ where } s \parthood s' \parthood r \text{ and } s' \compatible t\}
\]
\end{definition}

\begin{remark}
A world-state $w \in \worldstates$ is maximal in the sense that $t \parthood w$ for every compatible state $t \compatible w$.
\end{remark}

% ------------------------------------------------------------
% Task Relation Constraints
% ------------------------------------------------------------

\subsection{Task Relation Constraints}\label{sec:task-constraints}

\begin{definition}[Task Relation Constraints]\label{def:task-constraints}
The task relation $\taskrel$ satisfies:

\begin{enumerate}
  \item \textbf{Compositionality}: If $\task{s}{x}{t}$ and $\task{t}{y}{u}$, then $\task{s}{x+y}{u}$
  \item \textbf{Parthood (Left)}: If $d \parthood s$ and $\task{s}{x}{t}$, then $\task{d}{x}{r}$ for some $r \parthood t$
  \item \textbf{Parthood (Right)}: If $r \parthood t$ and $\task{s}{x}{t}$, then $\task{d}{x}{r}$ for some $d \parthood s$
  \item \textbf{Containment (Left)}: If $s \in \possible$, $d \parthood s$, and $\task{d}{x}{r}$, then $\task{s}{x}{\fusion{t}{r}}$ for some $t \in \statespace$
  \item \textbf{Containment (Right)}: If $t \in \possible$, $r \parthood t$, and $\task{d}{x}{r}$, then $\task{\fusion{s}{d}}{x}{t}$ for some $s \in \statespace$
  \item \textbf{Maximality}: If $s \in \statespace$ and $t \in \possible$, there is a maximal $t$-compatible part $r \in \maxcompat{s}{t}$
\end{enumerate}
\end{definition}

\begin{remark}
The Containment constraints ensure that tasks between parts of possible states can be extended to tasks between the states themselves. The Maximality constraint ensures that for any state and possible state, there exists a maximal part compatible with that possible state.
\end{remark}

See \leansrc{Logos.Core.Frame}{CoreFrame} for the Lean implementation.

% ------------------------------------------------------------
% World-History
% ------------------------------------------------------------

\subsection{World-History}\label{sec:world-history}

\begin{definition}[World-History]\label{def:world-history}
A \emph{world-history} over a core frame $\mframe$ is a function $\history : X \to \worldstates$ where:
\begin{itemize}
  \item $X \subseteq D$ is a convex subset of the temporal order
  \item $\task{\history(x)}{y-x}{\history(y)}$ for all times $x, y \in X$ where $x \leq y$
\end{itemize}
\end{definition}

\begin{notation}
The set of all world-histories over $\mframe$ is denoted $\historyspace$.
\end{notation}

\begin{remark}
World-histories assign world-states to times in a way that respects the task relation. The constraint ensures that consecutive world-states are connected by appropriate tasks. The set of maximal possible evolutions equals the set of world-histories (proven in Brast-McKie, ``Counterfactual Worlds'').
\end{remark}

% ------------------------------------------------------------
% Core Model
% ------------------------------------------------------------

\subsection{Core Model}\label{sec:core-model}

\begin{definition}[Core Model]\label{def:core-model}
A \emph{core model} is a structure $\model = \langle \statespace, \parthood, \temporalorder, \taskrel, \interp \rangle$ where:
\begin{itemize}
  \item $\langle \statespace, \parthood, \temporalorder, \taskrel \rangle$ is a core frame
  \item $\interp$ is an interpretation as in the Constitutive Foundation
\end{itemize}
\end{definition}

See \leansrc{Logos.Core.Model}{CoreModel} for the Lean implementation.

% ------------------------------------------------------------
% Truth Conditions
% ------------------------------------------------------------

\subsection{Truth Conditions}\label{sec:truth-conditions}

Truth is evaluated relative to a model $\model$, world-history $\history$, time $x \in D$, variable assignment $\assignment$, and temporal index $\tempindex = \langle i_1, i_2, \ldots \rangle$:

\subsubsection{Atomic Sentences}

\begin{definition}[Atomic Truth]\label{def:atomic-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies F(t_1, \ldots, t_n) &\iff \text{there is some } f \in \verifierset{F} \text{ where } f(\sem{t_1}^\assignment_\model, \ldots, \sem{t_n}^\assignment_\model) \parthood \history(x) \\
\model, \history, x, \assignment, \tempindex \notsatisfies F(t_1, \ldots, t_n) &\iff \text{there is some } f \in \falsifierset{F} \text{ where } f(\sem{t_1}^\assignment_\model, \ldots, \sem{t_n}^\assignment_\model) \parthood \history(x)
\end{align}
\end{definition}

\begin{remark}
It is derivable that $\model, \history, x, \assignment, \tempindex \satisfies \metaA$ iff it is not the case that $\model, \history, x, \assignment, \tempindex \notsatisfies \metaA$. This justifies using $\satisfies$ alone for truth and $\notsatisfies$ for falsehood.
\end{remark}

\subsubsection{Lambda Abstraction and Quantification}

\begin{definition}[Lambda and Quantification]\label{def:lambda-quant-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies (\lambda y.\metaA)(t) &\iff \model, \history, x, \assignsub{\sem{t}^\assignment_\model}{y}, \tempindex \satisfies \metaA \\
\model, \history, x, \assignment, \tempindex \satisfies \forall y.\metaA &\iff \model, \history, x, \assignsub{s}{y}, \tempindex \satisfies \metaA \text{ for all } s \in \statespace
\end{align}
\end{definition}

\subsubsection{Actuality Predicate}

\begin{definition}[Actuality]\label{def:actuality-truth}
\[
\model, \history, x, \assignment, \tempindex \satisfies \actual(t) \iff \sem{t}^\assignment_\model \parthood \history(x)
\]
\end{definition}

\begin{remark}[Restricted Quantification]
The actuality predicate enables restricting quantification to actually existing objects:
\[
\forall y(\actual(y) \to \metaA) \text{ is true iff } \metaA \text{ holds for all states that are parts of } \history(x)
\]
The unrestricted universal quantifier validates the Barcan formulas ($\forall x \nec\metaA \to \nec\forall x\metaA$ and its converse), while the actuality-restricted quantifier does not.
\end{remark}

\subsubsection{Extensional Connectives}

\begin{definition}[Extensional Connectives]\label{def:extensional-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies \neg\metaA &\iff \model, \history, x, \assignment, \tempindex \notsatisfies \metaA \\
\model, \history, x, \assignment, \tempindex \satisfies \metaA \land \metaB &\iff \model, \history, x, \assignment, \tempindex \satisfies \metaA \text{ and } \model, \history, x, \assignment, \tempindex \satisfies \metaB \\
\model, \history, x, \assignment, \tempindex \satisfies \metaA \lor \metaB &\iff \model, \history, x, \assignment, \tempindex \satisfies \metaA \text{ or } \model, \history, x, \assignment, \tempindex \satisfies \metaB \\
\model, \history, x, \assignment, \tempindex \satisfies \metaA \to \metaB &\iff \model, \history, x, \assignment, \tempindex \notsatisfies \metaA \text{ or } \model, \history, x, \assignment, \tempindex \satisfies \metaB
\end{align}
\end{definition}

\subsubsection{Modal Operators}

\begin{definition}[Modal Operators]\label{def:modal-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies \nec\metaA &\iff \model, \alpha, x, \assignment, \tempindex \satisfies \metaA \text{ for all } \alpha \in \historyspace \\
\model, \history, x, \assignment, \tempindex \satisfies \poss\metaA &\iff \model, \alpha, x, \assignment, \tempindex \satisfies \metaA \text{ for some } \alpha \in \historyspace
\end{align}
\end{definition}

\begin{remark}
$\poss\metaA \equiv \neg\nec\neg\metaA$. Metaphysical necessity can also be defined via counterfactuals: $\nec\metaA := \top \boxright \metaA$. This yields an S5 modal logic.
\end{remark}

\subsubsection{Core Tense Operators}

\begin{definition}[Core Tense Operators]\label{def:tense-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies \always\metaA &\iff \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for all } y \in D \text{ where } y < x \\
\model, \history, x, \assignment, \tempindex \satisfies \willalways\metaA &\iff \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for all } y \in D \text{ where } y > x \\
\model, \history, x, \assignment, \tempindex \satisfies \waspast\metaA &\iff \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for some } y \in D \text{ where } y < x \\
\model, \history, x, \assignment, \tempindex \satisfies \willfuture\metaA &\iff \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for some } y \in D \text{ where } y > x
\end{align}
\end{definition}

\begin{remark}[Equivalences]
$\waspast\metaA \equiv \neg\always\neg\metaA$ and $\willfuture\metaA \equiv \neg\willalways\neg\metaA$.
\end{remark}

\subsubsection{Extended Tense Operators}

\begin{definition}[Since and Until]\label{def:since-until-truth}
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies \metaA \since \metaB &\iff \text{there exists } z < x \text{ where } \model, \history, z, \assignment, \tempindex \satisfies \metaB \notag \\
  &\quad \text{and } \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for all } y \text{ where } z < y < x \\
\model, \history, x, \assignment, \tempindex \satisfies \metaA \until \metaB &\iff \text{there exists } z > x \text{ where } \model, \history, z, \assignment, \tempindex \satisfies \metaB \notag \\
  &\quad \text{and } \model, \history, y, \assignment, \tempindex \satisfies \metaA \text{ for all } y \text{ where } x < y < z
\end{align}
\end{definition}

\begin{remark}
``$\metaA$ since $\metaB$'' means $\metaB$ was true at some past time, and $\metaA$ has been true ever since. ``$\metaA$ until $\metaB$'' means $\metaB$ will be true at some future time, and $\metaA$ is true until then.
\end{remark}

\subsubsection{Counterfactual Conditional}

\begin{definition}[Counterfactual Conditional]\label{def:counterfactual-truth}
\[
\model, \history, x, \assignment, \tempindex \satisfies \metaphi \boxright \metaC \iff \text{for all } t \in \verifierset{\metaphi} \text{ and } \beta \in \historyspace:
\]
if $\fusion{s}{t} \parthood \beta(x)$ for some maximal $t$-compatible part $s \in \maxcompat{\history(x)}{t}$, then $\model, \beta, x, \assignment, \tempindex \satisfies \metaC$
\end{definition}

\begin{definition}[Imposition]\label{def:imposition}
We write $\imposition{t}{w}{w'}$ (``imposing $t$ on $w$ yields $w'$'') iff there exists a maximal $t$-compatible part $s \in \maxcompat{w}{t}$ where $\fusion{s}{t} \parthood w'$.
\end{definition}

\begin{remark}[Intuitive Reading]
A counterfactual ``if $\metaphi$ were the case, then $\metaC$'' is true at world $\history$ and time $x$ iff the consequent $\metaC$ is true in any world $\beta$ at $x$ where $\beta(x)$ is the result of minimally changing $\history(x)$ to make the antecedent $\metaphi$ true.
\end{remark}

\subsubsection{Store and Recall Operators}

\begin{definition}[Store and Recall]\label{def:store-recall-truth}
For cross-temporal reference within counterfactual evaluation, the context includes a temporal index $\tempindex = \langle i_1, i_2, \ldots \rangle$ of stored times:
\begin{align}
\model, \history, x, \assignment, \tempindex \satisfies \store{k}\metaA &\iff \model, \history, x, \assignment, \tempindex[x/i_k] \satisfies \metaA \\
\model, \history, x, \assignment, \tempindex \satisfies \recall{k}\metaA &\iff \model, \history, i_k, \assignment, \tempindex \satisfies \metaA
\end{align}
where $\tempindex[x/i_k]$ replaces $i_k$ with current time $x$.
\end{definition}

\begin{example}[Tensed Counterfactuals]
\begin{itemize}
  \item $\recall{1}(\metaB \boxright \willfuture\always)$ --- ``If $\metaB$ had occurred at the stored time, then $\always$ would have occurred at some future time''
  \item $\store{2}\recall{1}(\metaB \boxright \recall{2}\always)$ --- ``Store now, recall past time, if $\metaB$ then $\always$ at the stored present''
\end{itemize}
\end{example}

See \leansrc{Logos.Core.Semantics}{Satisfies} for the Lean implementation.

% ------------------------------------------------------------
% Bimodal Interaction Principles
% ------------------------------------------------------------

\subsection{Bimodal Interaction Principles}\label{sec:bimodal-interaction}

The task semantics validates these perpetuity principles connecting modal and temporal operators:

\begin{definition}[Perpetuity Principles]\label{def:perpetuity}
\begin{align}
\textbf{P1}: \quad &\nec\metaphi \to \alwaystemporal\metaphi && \text{Necessary implies always} \\
\textbf{P2}: \quad &\sometimestemporal\metaphi \to \poss\metaphi && \text{Sometimes implies possible} \\
\textbf{P3}: \quad &\nec\alwaystemporal\metaphi \leftrightarrow \alwaystemporal\nec\metaphi && \text{Necessary-always commutativity} \\
\textbf{P4}: \quad &\poss\sometimestemporal\metaphi \leftrightarrow \sometimestemporal\poss\metaphi && \text{Possible-sometimes commutativity} \\
\textbf{P5}: \quad &\nec\metaphi \to \nec\alwaystemporal\metaphi && \text{Necessary implies necessary-always} \\
\textbf{P6}: \quad &\sometimestemporal\poss\metaphi \to \poss\metaphi && \text{Sometimes-possible implies possible}
\end{align}
\end{definition}

% ------------------------------------------------------------
% Temporal Frame Constraints
% ------------------------------------------------------------

\subsection{Temporal Frame Constraints}\label{sec:temporal-constraints}

Different temporal structures yield different valid principles. The framework does not assume discrete time:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Constraint} & \textbf{Description} & \textbf{Corresponding Axiom} \\
\midrule
Dense & Between any two times there is another & $\willalways\willalways\metaphi \to \willalways\metaphi$ \\
Complete & Every bounded set has a least upper bound & $\alwaystemporal(\always\metaphi \to \willfuture\always\metaphi) \to (\always\metaphi \to \willalways\metaphi)$ \\
Unbounded Past & No earliest time & $\waspast\top$ \\
Unbounded Future & No latest time & $\willfuture\top$ \\
\bottomrule
\end{tabular}
\caption{Temporal frame constraints and corresponding axioms}
\label{tab:temporal-constraints}
\end{table}

% ------------------------------------------------------------
% Logical Consequence
% ------------------------------------------------------------

\subsection{Logical Consequence}\label{sec:logical-consequence-core}

\begin{definition}[Logical Consequence (Core Extension)]\label{def:consequence-core}
\[
\context \satisfies \metaA \iff \text{for any } \model, \history \in \historyspace, x \in D, \assignment, \tempindex: \text{if } \model, \history, x, \assignment, \tempindex \satisfies \metaB \text{ for all } \metaB \in \context, \text{ then } \model, \history, x, \assignment, \tempindex \satisfies \metaA
\]
\end{definition}

\begin{remark}
Unlike the Constitutive Foundation, the Core Extension evaluates truth relative to world-histories and times, not just verification by states. The hyperintensional distinctions are preserved---propositions still differ if their exact verifiers differ---but the Core Extension adds the intensional layer needed to evaluate sentences with modal and temporal operators.
\end{remark}

\end{document}
