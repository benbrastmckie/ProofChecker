\documentclass[../LogosReference.tex]{subfiles}
\begin{document}

% ============================================================================
% Section: Constitutive Foundation
% ============================================================================

\section{Constitutive Foundation}\label{sec:constitutive-foundation}

The Constitutive Foundation provides the foundational semantic structure based on exact truthmaker semantics. Evaluation is hyperintensional, distinguishing propositions that agree on truth-value across all possible worlds but differ in their exact verification and falsification conditions.

% ------------------------------------------------------------
% Syntactic Primitives
% ------------------------------------------------------------

\subsection{Syntactic Primitives}\label{sec:syntactic-primitives}

The Constitutive Foundation interprets the following syntactic primitives:

\begin{itemize}
  \item \textbf{Variables}: $x, y, z, \ldots$ (ranging over states)
  \item \textbf{Individual constants}: $a, b, c, \ldots$ (0-place function symbols)
  \item \textbf{n-place function symbols}: $f, g, h, \ldots$
  \item \textbf{n-place predicates}: $F, G, H, \ldots$
  \item \textbf{Sentence letters}: $p, q, r, \ldots$ (0-place predicates)
  \item \textbf{Lambda abstraction}: $\lambda x.\metaA$ (binding variable $x$ in formula $\metaA$)
  \item \textbf{Logical connectives}: $\neg, \land, \lor, \top, \bot, \propid$
\end{itemize}

% ------------------------------------------------------------
% Constitutive Frame
% ------------------------------------------------------------

\subsection{Constitutive Frame}\label{sec:constitutive-frame}

\begin{definition}[Constitutive Frame]\label{def:constitutive-frame}
A \emph{constitutive frame} is a structure $\mframe = \langle \statespace, \parthood \rangle$ where:
\begin{itemize}
  \item $\statespace$ is a nonempty set of \emph{states}
  \item $\parthood$ is a partial order on $\statespace$ making $\langle \statespace, \parthood \rangle$ a complete lattice
\end{itemize}
\end{definition}

\begin{remark}
The constitutive frame is non-modal: possibility and compatibility cannot be defined at this level since they require the task relation introduced in the Core Extension.
\end{remark}

\begin{remark}
The lattice structure provides:
\begin{itemize}
  \item \textbf{Null state} $\nullstate$: The bottom element (fusion of the empty set)
  \item \textbf{Full state} $\fullstate$: The top element (fusion of all states)
  \item \textbf{Fusion} $\fusion{s}{t}$: The least upper bound of $s$ and $t$
\end{itemize}
\end{remark}

See \leansrc{Logos.Foundation.Frame}{ConstitutiveFrame} for the Lean implementation.

% ------------------------------------------------------------
% Constitutive Model
% ------------------------------------------------------------

\subsection{Constitutive Model}\label{sec:constitutive-model}

\begin{definition}[Constitutive Model]\label{def:constitutive-model}
A \emph{constitutive model} is a structure $\model = \langle \statespace, \parthood, \interp \rangle$ where:
\begin{itemize}
  \item $\langle \statespace, \parthood \rangle$ is a constitutive frame
  \item $\interp$ is an interpretation function assigning meanings to non-logical vocabulary
\end{itemize}
\end{definition}

\begin{definition}[Interpretation Function]\label{def:interpretation}
The interpretation function $\interp$ assigns:
\begin{itemize}
  \item \textbf{n-place function symbols} $f \mapsto \interp(f) : \statespace^n \to \statespace$ (0-place symbols are individual constants mapping to states)
  \item \textbf{n-place predicates} $F \mapsto \langle \verifierset{F}, \falsifierset{F} \rangle$ where:
    \begin{itemize}
      \item $\verifierset{F}$: set of functions $\statespace^n \to \statespace$ (verifier functions)
      \item $\falsifierset{F}$: set of functions $\statespace^n \to \statespace$ (falsifier functions)
    \end{itemize}
  \item \textbf{Sentence letters} (0-place predicates) $p \mapsto \langle v_p, f_p \rangle$ of verifier and falsifier state sets
\end{itemize}
\end{definition}

\begin{remark}[Containment Constraint]
For any function $f$ in $\verifierset{F}$ or $\falsifierset{F}$ and any $n$ states $a_1, \ldots, a_n$, these states are all parts of $f(a_1, \ldots, a_n)$. However, $f(a_1, \ldots, a_n)$ may have additional parts beyond the input states.
\end{remark}

\begin{remark}[Predicate Intuition]
For 1-place predicates, the functions in $\verifierset{F}$ and $\falsifierset{F}$ take an object (which is itself a state) as input and return that object instantiating a verifying or falsifying property instance for the property in question.
\end{remark}

See \leansrc{Logos.Foundation.Model}{ConstitutiveModel} for the Lean implementation.

% ------------------------------------------------------------
% Variable Assignment
% ------------------------------------------------------------

\subsection{Variable Assignment}\label{sec:variable-assignment}

\begin{definition}[Variable Assignment]\label{def:variable-assignment}
A \emph{variable assignment} $\assignment$ is a function from variables to states: $\assignment : \mathrm{Var} \to \statespace$
\end{definition}

\begin{notation}
Greek letters ($\history, \alpha, \beta, \ldots$) are reserved for world-histories. The letter $\assignment$ (with subscripts $\assignment_1, \assignment_2, \ldots$) denotes variable assignments, chosen for compatibility across \LaTeX, markdown, and Lean notation.
\end{notation}

\begin{definition}[Term Extension]\label{def:term-extension}
The \emph{extension} of a term relative to model $\model$ and assignment $\assignment$:
\begin{itemize}
  \item \textbf{Variable} $x$: $\sem{x}^\assignment_\model = \assignment(x)$
  \item \textbf{Function application} $f(t_1, \ldots, t_n)$: $\sem{f(t_1, \ldots, t_n)}^\assignment_\model = \interp(f)(\sem{t_1}^\assignment_\model, \ldots, \sem{t_n}^\assignment_\model)$
\end{itemize}
\end{definition}

See \leansrc{Logos.Foundation.Assignment}{Assignment} for the Lean implementation.

% ------------------------------------------------------------
% Verification and Falsification Clauses
% ------------------------------------------------------------

\subsection{Verification and Falsification Clauses}\label{sec:verification-falsification}

A state $s$ \emph{verifies} ($\verifies$) or \emph{falsifies} ($\falsifies$) a formula $\metaA$ relative to model $\model$ and assignment $\assignment$:

\subsubsection{Atomic Formulas}\label{sec:atomic-formulas}

\begin{definition}[Atomic Verification and Falsification]\label{def:atomic-verification}
\begin{align}
\model, \assignment, s \verifies F(t_1, \ldots, t_n) &\iff \exists f \in \verifierset{F} : s = f(\sem{t_1}^\assignment_\model, \ldots, \sem{t_n}^\assignment_\model) \\
\model, \assignment, s \falsifies F(t_1, \ldots, t_n) &\iff \exists f \in \falsifierset{F} : s = f(\sem{t_1}^\assignment_\model, \ldots, \sem{t_n}^\assignment_\model)
\end{align}
\end{definition}

\subsubsection{Lambda Abstraction}\label{sec:lambda-abstraction}

\begin{definition}[Lambda Verification and Falsification]\label{def:lambda-verification}
\begin{align}
\model, \assignment, s \verifies (\lambda x.\metaA)(t) &\iff \model, \assignsub{\sem{t}^\assignment_\model}{x}, s \verifies \metaA \\
\model, \assignment, s \falsifies (\lambda x.\metaA)(t) &\iff \model, \assignsub{\sem{t}^\assignment_\model}{x}, s \falsifies \metaA
\end{align}
where $\assignsub{v}{x}$ is the assignment that maps $x$ to $v$ and agrees with $\assignment$ on all other variables.
\end{definition}

\subsubsection{Negation}\label{sec:negation}

\begin{definition}[Negation Verification and Falsification]\label{def:negation-verification}
\begin{align}
\model, \assignment, s \verifies \neg\metaA &\iff \model, \assignment, s \falsifies \metaA \\
\model, \assignment, s \falsifies \neg\metaA &\iff \model, \assignment, s \verifies \metaA
\end{align}
\end{definition}

\subsubsection{Conjunction}\label{sec:conjunction}

\begin{definition}[Conjunction Verification and Falsification]\label{def:conjunction-verification}
\begin{align}
\model, \assignment, s \verifies \metaA \land \metaB &\iff s = \fusion{t}{u} \text{ for some } t, u \text{ where } \model, \assignment, t \verifies \metaA \text{ and } \model, \assignment, u \verifies \metaB \\
\model, \assignment, s \falsifies \metaA \land \metaB &\iff \model, \assignment, s \falsifies \metaA, \text{ or } \model, \assignment, s \falsifies \metaB, \text{ or } \notag \\
  &\quad\;\; s = \fusion{t}{u} \text{ for some } t, u \text{ where } \model, \assignment, t \falsifies \metaA \text{ and } \model, \assignment, u \falsifies \metaB
\end{align}
\end{definition}

\subsubsection{Disjunction}\label{sec:disjunction}

\begin{definition}[Disjunction Verification and Falsification]\label{def:disjunction-verification}
\begin{align}
\model, \assignment, s \verifies \metaA \lor \metaB &\iff \model, \assignment, s \verifies \metaA, \text{ or } \model, \assignment, s \verifies \metaB, \text{ or } \notag \\
  &\quad\;\; s = \fusion{t}{u} \text{ for some } t, u \text{ where } \model, \assignment, t \verifies \metaA \text{ and } \model, \assignment, u \verifies \metaB \\
\model, \assignment, s \falsifies \metaA \lor \metaB &\iff s = \fusion{t}{u} \text{ for some } t, u \text{ where } \model, \assignment, t \falsifies \metaA \text{ and } \model, \assignment, u \falsifies \metaB
\end{align}
\end{definition}

\subsubsection{Top and Bottom}\label{sec:top-bottom}

\begin{definition}[Top and Bottom Verification and Falsification]\label{def:top-bottom-verification}
\begin{align}
&\model, \assignment, s \verifies \top \text{ for all } s \in \statespace \\
&\model, \assignment, s \falsifies \top \iff s = \fullstate \text{ (full state)} \\
&\model, \assignment, s \not\verifies \bot \text{ for all } s \\
&\model, \assignment, s \falsifies \bot \iff s = \nullstate \text{ (null state)}
\end{align}
\end{definition}

\subsubsection{Propositional Identity}\label{sec:propositional-identity}

\begin{definition}[Propositional Identity Verification and Falsification]\label{def:propid-verification}
\begin{align}
\model, \assignment, s \verifies \metaA \propid \metaB &\iff s = \nullstate \text{ and } \{t : \model, \assignment, t \verifies \metaA\} = \{t : \model, \assignment, t \verifies \metaB\} \notag \\
  &\quad \text{and } \{t : \model, \assignment, t \falsifies \metaA\} = \{t : \model, \assignment, t \falsifies \metaB\} \\
\model, \assignment, s \falsifies \metaA \propid \metaB &\iff s = \nullstate \text{ and } (\{t : \model, \assignment, t \verifies \metaA\} \neq \{t : \model, \assignment, t \verifies \metaB\} \notag \\
  &\quad \text{or } \{t : \model, \assignment, t \falsifies \metaA\} \neq \{t : \model, \assignment, t \falsifies \metaB\})
\end{align}
\end{definition}

See \leansrc{Logos.Foundation.Semantics}{verifies} for the Lean implementation.

% ------------------------------------------------------------
% Essence and Ground
% ------------------------------------------------------------

\subsection{Essence and Ground}\label{sec:essence-ground}

These constitutive relations can be defined via propositional identity:

\begin{definition}[Essence and Ground]\label{def:essence-ground}
\begin{align}
\metaA \essence \metaB &:= \metaA \land \metaB \propid \metaB && \text{``$\metaA$ is essential to $\metaB$'' (conjunctive part)} \\
\metaA \ground \metaB &:= \metaA \lor \metaB \propid \metaB && \text{``$\metaA$ grounds $\metaB$'' (disjunctive part)}
\end{align}
\end{definition}

\begin{remark}[Negation Distribution]
These relations are interrelated through negation:
\begin{itemize}
  \item $\metaA \essence \metaB$ iff $\neg\metaA \ground \neg\metaB$
  \item $\metaA \ground \metaB$ iff $\neg\metaA \essence \neg\metaB$
\end{itemize}
\end{remark}

\begin{remark}[Bilattice Structure]
The space of bilateral propositions forms a non-interlaced bilattice where:
\begin{itemize}
  \item $\langle P, \essence \rangle$ and $\langle P, \ground \rangle$ are complete lattices
  \item Negation exchanges the two orderings: $X \ground Y$ iff $\neg X \essence \neg Y$
  \item Conjunction and disjunction are the least upper bounds with respect to $\essence$ and $\ground$ respectively
\end{itemize}
\end{remark}

See \leansrc{Logos.Foundation.Relations}{essence} for the Lean implementation.

% ------------------------------------------------------------
% Bilateral Propositions
% ------------------------------------------------------------

\subsection{Bilateral Propositions}\label{sec:bilateral-propositions}

\begin{definition}[Bilateral Proposition]\label{def:bilateral-proposition}
A \emph{bilateral proposition} is an ordered pair $\langle V, F \rangle$ where:
\begin{itemize}
  \item $V$ and $F$ are subsets of $\statespace$ closed under fusion
  \item $\langle V, F \rangle$ is \emph{exclusive}: states in $V$ are incompatible with states in $F$
  \item $\langle V, F \rangle$ is \emph{exhaustive}: every possible state is compatible with some state in $V$ or $F$
\end{itemize}
\end{definition}

\begin{definition}[Propositional Operations]\label{def:propositional-operations}
\begin{align}
X \product Y &:= \{\fusion{s}{t} : s \in X, t \in Y\} && \text{(Product)} \\
X \psum Y &:= X \cup Y \cup (X \product Y) && \text{(Sum)} \\
\langle V, F \rangle \land \langle V', F' \rangle &:= \langle V \product V', F \psum F' \rangle && \text{(Conjunction)} \\
\langle V, F \rangle \lor \langle V', F' \rangle &:= \langle V \psum V', F \product F' \rangle && \text{(Disjunction)} \\
\neg\langle V, F \rangle &:= \langle F, V \rangle && \text{(Negation)}
\end{align}
\end{definition}

See \leansrc{Logos.Foundation.Proposition}{BilateralProp} for the Lean implementation.

% ------------------------------------------------------------
% Logical Consequence
% ------------------------------------------------------------

\subsection{Logical Consequence}\label{sec:logical-consequence-foundation}

\begin{definition}[Logical Consequence (Constitutive Foundation)]\label{def:consequence-foundation}
Logical consequence at the Constitutive Foundation is restricted to propositional identity sentences:
\[
\context \satisfies \metaA \iff \text{for any model } \model \text{ and assignment } \assignment : \text{if } \model, \assignment, \nullstate \verifies \metaB \text{ for all } \metaB \in \context, \text{ then } \model, \assignment, \nullstate \verifies \metaA
\]
That is, $\metaA$ is a consequence of $\context$ iff the null state verifies $\metaA$ in any model where it verifies all premises.
\end{definition}

\begin{remark}[Identity Sentences and Evaluation Overlap]
Identity sentences are formed from extensional (non-identity) sentences: $\metaA \propid \metaB$ where $\metaA$ and $\metaB$ are atomic sentences or built from $\neg, \land, \lor$. The logical consequences holding between identity sentences are preserved by further extensions. However, the Constitutive Foundation lacks the semantic resources to evaluate non-identity sentences, which depend on contingent states of affairs rather than purely structural relations in state space. The Constitutive Foundation is nevertheless important for defining a logic of propositional identity. The same theorems valid at this level remain valid in the Core Extension, though the Core Extension's definition of logical consequence differs, quantifying over world-histories and times in addition to models and variable assignments.
\end{remark}

\end{document}
