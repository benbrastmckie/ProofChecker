# Subagent Delegation Guide

**Version**: 1.0
**Status**: Active
**Created**: 2025-12-26
**Purpose**: Define safe delegation patterns to prevent hangs, cycles, and timeouts

---

## Overview

This guide defines how commands and agents safely delegate work to subagents. Following these patterns prevents the delegation hang issues identified in Task 191.

**Problems Solved**:
- Delegation hangs (Task 191 Root Cause #1, #3)
- Infinite delegation loops (Task 191 Root Cause #2)
- Missing timeouts (Task 191 Root Cause #4)
- Coordination gaps (Task 191 Root Cause #5)

---

## Core Principles

### 1. Session ID Tracking

Every delegation MUST have a unique session ID for tracking and debugging.

**Format**: `sess_{timestamp}_{random_6char}`

**Example**: `sess_20251226_abc123`

**Generation**:
```python
import time
import random
import string

def generate_session_id():
    timestamp = int(time.time())
    random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
    return f"sess_{timestamp}_{random_chars}"
```

**Usage**:
- Generated by caller before invoking subagent
- Passed to subagent in delegation context
- Returned by subagent in metadata
- Used for tracking in orchestrator registry

### 2. Delegation Depth Limits

Maximum delegation depth: **3 levels**

**Why**: Prevents infinite delegation loops and keeps system understandable.

**Depth Counting**:
- Orchestrator → Command: depth = 0 (not counted)
- Command → Subagent: depth = 1
- Subagent → Specialist: depth = 2
- Specialist → Helper: depth = 3 (max)
- Helper → Another Agent: **BLOCKED** (exceeds limit)

**Enforcement**:
- Caller increments depth before delegating
- Caller checks: `if depth >= 3: return error`
- Subagent receives depth in delegation context
- Subagent returns depth in metadata

### 3. Delegation Path Tracking

Track the full delegation path to detect cycles.

**Path Format**: Array of agent names in delegation order

**Example**: `["orchestrator", "implement", "task-executor", "implementer"]`

**Cycle Detection**:
```python
def check_cycle(delegation_path, target_agent):
    if target_agent in delegation_path:
        raise CycleError(f"Cycle detected: {delegation_path} → {target_agent}")
    return False
```

**Usage**:
- Caller appends self to path before delegating
- Caller checks if target already in path (cycle)
- Subagent receives path in delegation context
- Subagent returns path in metadata

### 4. Timeout Enforcement

All delegations MUST have timeouts to prevent indefinite hangs.

**Default Timeouts**:
- Research: 3600s (1 hour)
- Planning: 1800s (30 minutes)
- Implementation: 7200s (2 hours)
- Simple operations: 300s (5 minutes)

**Timeout Handling**:
```python
try:
    result = invoke_subagent(timeout=3600)
except TimeoutError:
    # Graceful degradation
    partial_results = check_for_artifacts()
    return {
        "status": "partial",
        "summary": "Operation timed out after 3600s",
        "artifacts": partial_results,
        "errors": [{
            "type": "timeout",
            "message": "Subagent exceeded timeout",
            "code": "TIMEOUT",
            "recoverable": true,
            "recommendation": "Resume with same command to continue"
        }]
    }
```

**Principles**:
- Never wait indefinitely
- Return partial results if available
- Mark task as IN PROGRESS (not failed)
- Provide actionable recovery message

### 5. Return Validation

All subagent returns MUST be validated against the standard format.

**Validation Steps**:
1. Check return is valid JSON
2. Validate against `subagent-return-format.md` schema
3. Check session_id matches expected
4. Validate all required fields present
5. Check status is valid enum value

**Validation Example**:
```python
def validate_return(return_obj, expected_session_id):
    # 1. Check JSON structure
    assert isinstance(return_obj, dict), "Return must be JSON object"
    
    # 2. Check required fields
    required = ["status", "summary", "artifacts", "metadata"]
    for field in required:
        assert field in return_obj, f"Missing required field: {field}"
    
    # 3. Validate status
    valid_statuses = ["completed", "failed", "partial", "blocked"]
    assert return_obj["status"] in valid_statuses, f"Invalid status: {return_obj['status']}"
    
    # 4. Check session ID
    actual_session = return_obj["metadata"]["session_id"]
    assert actual_session == expected_session_id, f"Session ID mismatch: {actual_session} != {expected_session_id}"
    
    # 5. Validate summary length
    summary = return_obj["summary"]
    assert len(summary) > 0, "Summary cannot be empty"
    assert len(summary) <= 500, "Summary too long (max 500 chars)"
    
    return True
```

---

## Standard Delegation Pattern

All commands that invoke subagents MUST follow this pattern:

### Stage 1: Prepare Delegation

```xml
<stage id="N" name="PrepareDelegation">
  <action>Prepare delegation context</action>
  <process>
    1. Generate unique session_id
    2. Get current delegation_depth from context (default 0)
    3. Get current delegation_path from context (default [])
    4. Increment depth: new_depth = depth + 1
    5. Check depth limit: if new_depth >= 3: return error
    6. Append self to path: new_path = path + [self_name]
    7. Check for cycles: if target in new_path: return error
    8. Determine timeout based on operation type
    9. Store session_id for later validation
  </process>
  <delegation_context>
    {
      "session_id": "sess_20251226_abc123",
      "delegation_depth": 1,
      "delegation_path": ["orchestrator", "implement"],
      "timeout": 3600
    }
  </delegation_context>
</stage>
```

### Stage 2: Invoke Subagent

```xml
<stage id="N+1" name="InvokeSubagent">
  <action>Invoke subagent with delegation context</action>
  <process>
    1. Route to appropriate subagent
    2. Pass delegation context
    3. Pass task-specific parameters
    4. Set timeout from delegation context
    5. Begin monitoring (if orchestrator)
  </process>
  <invocation>
    task_tool(
      subagent_type="researcher",
      prompt="Research topic: {topic}",
      session_id=delegation_context["session_id"],
      delegation_depth=delegation_context["delegation_depth"],
      delegation_path=delegation_context["delegation_path"],
      timeout=delegation_context["timeout"]
    )
  </invocation>
</stage>
```

### Stage 3: Receive Results

```xml
<stage id="N+2" name="ReceiveResults">
  <action>Wait for and receive subagent results</action>
  <process>
    1. Poll for completion (max timeout seconds)
    2. Receive return object from subagent
    3. Handle timeout if no response
    4. Handle exceptions if invocation failed
  </process>
  <timeout_handling>
    If timeout (no response after {timeout}s):
      1. Log timeout error with session_id
      2. Check for partial artifacts on disk
      3. Return partial status with artifacts found
      4. Provide recovery message
      5. Do NOT mark task as failed
  </timeout_handling>
  <exception_handling>
    If exception during invocation:
      1. Log exception with stack trace
      2. Return failed status
      3. Provide actionable error message
      4. Recommend troubleshooting steps
  </exception_handling>
</stage>
```

### Stage 4: Validate Return

```xml
<stage id="N+3" name="ValidateReturn">
  <action>Validate return against standard format</action>
  <process>
    1. Validate JSON structure
    2. Validate against subagent-return-format.md schema
    3. Check session_id matches expected
    4. Validate all required fields present
    5. Validate status is valid enum
    6. Validate summary within length limits
    7. Validate artifacts have valid paths
  </process>
  <validation_failure>
    If validation fails:
      1. Log validation error with details
      2. Return failed status
      3. Include original return for debugging
      4. Recommend subagent fix
  </validation_failure>
</stage>
```

### Stage 5: Process Results

```xml
<stage id="N+4" name="ProcessResults">
  <action>Extract and process validated results</action>
  <process>
    1. Extract status from return
    2. Extract summary for user/caller
    3. Extract artifacts for linking
    4. Extract errors if status != completed
    5. Extract next_steps if present
    6. Prepare for next stage (postflight/return)
  </process>
  <status_handling>
    If status == "completed":
      - All work finished successfully
      - Proceed to postflight with artifacts
    If status == "partial":
      - Some work completed
      - Keep task IN PROGRESS
      - Save partial results
    If status == "failed":
      - No usable results
      - Handle errors
      - Provide recovery steps
    If status == "blocked":
      - Cannot proceed
      - Identify blocker
      - Request user intervention
  </status_handling>
</stage>
```

---

## Delegation Context Schema

Every delegation MUST include this context:

```json
{
  "session_id": "sess_{timestamp}_{random}",
  "delegation_depth": 1,
  "delegation_path": ["orchestrator", "command", "agent"],
  "timeout": 3600,
  "caller": "command_name",
  "task_context": {
    "task_number": 191,
    "language": "lean",
    "complexity": "high"
  }
}
```

**Required Fields**:
- `session_id`: Unique identifier for this delegation
- `delegation_depth`: Current depth (0-2, max 3)
- `delegation_path`: Array of agent names in delegation chain
- `timeout`: Maximum wait time in seconds

**Optional Fields**:
- `caller`: Name of calling agent/command
- `task_context`: Additional context for the task

---

## Orchestrator Delegation Registry

The orchestrator maintains an in-memory registry of active delegations:

```javascript
{
  "sess_20251226_abc123": {
    "command": "implement",
    "subagent": "task-executor",
    "task_number": 191,
    "start_time": "2025-12-26T10:00:00Z",
    "timeout": 3600,
    "deadline": "2025-12-26T11:00:00Z",
    "status": "running",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "implement", "task-executor"]
  }
}
```

**Registry Operations**:

1. **Register** (on delegation start):
   ```python
   def register_delegation(session_id, context):
       registry[session_id] = {
           "command": context["caller"],
           "subagent": context["target"],
           "start_time": datetime.now(),
           "timeout": context["timeout"],
           "deadline": datetime.now() + timedelta(seconds=context["timeout"]),
           "status": "running",
           "delegation_depth": context["delegation_depth"],
           "delegation_path": context["delegation_path"]
       }
   ```

2. **Monitor** (periodic check):
   ```python
   def monitor_delegations():
       now = datetime.now()
       for session_id, delegation in registry.items():
           if now > delegation["deadline"] and delegation["status"] == "running":
               handle_timeout(session_id, delegation)
   ```

3. **Complete** (on return):
   ```python
   def complete_delegation(session_id, return_obj):
       if session_id in registry:
           registry[session_id]["status"] = "completed"
           registry[session_id]["return"] = return_obj
           # Can remove from registry or keep for audit
           del registry[session_id]
   ```

4. **Cleanup** (on timeout):
   ```python
   def handle_timeout(session_id, delegation):
       delegation["status"] = "timeout"
       # Log timeout
       log_error({
           "type": "timeout",
           "session_id": session_id,
           "command": delegation["command"],
           "subagent": delegation["subagent"],
           "timeout": delegation["timeout"]
       })
       # Return error to caller
       return_timeout_error(session_id)
       # Remove from registry
       del registry[session_id]
   ```

---

## Error Propagation

Errors MUST propagate up the delegation chain:

### Subagent Error

```json
{
  "status": "failed",
  "summary": "Implementation failed due to build errors",
  "artifacts": [],
  "errors": [{
    "type": "build_error",
    "message": "Lean file compilation failed: 3 type errors",
    "code": "BUILD_ERROR",
    "recoverable": true,
    "recommendation": "Fix type errors and retry"
  }],
  "metadata": {
    "session_id": "sess_20251226_abc123",
    "agent_type": "implementer"
  }
}
```

### Command Handling

```python
def handle_error_return(return_obj):
    errors = return_obj["errors"]
    
    # Log to errors.json
    for error in errors:
        log_error({
            "type": error["type"],
            "message": error["message"],
            "code": error["code"],
            "context": {
                "command": current_command,
                "task_number": current_task,
                "session_id": return_obj["metadata"]["session_id"]
            }
        })
    
    # Check if recoverable
    if all(e["recoverable"] for e in errors):
        # Provide recovery instructions
        return f"Task failed but is recoverable. {errors[0]['recommendation']}"
    else:
        # Non-recoverable failure
        return f"Task failed. Manual intervention required: {errors[0]['message']}"
```

---

## Common Delegation Patterns

### Pattern 1: Simple Delegation (No Further Delegation)

**Use Case**: Command → Subagent (subagent does work directly)

**Example**: `/task` → `atomic-task-numberer`

```xml
<delegation>
  <depth>1</depth>
  <path>["orchestrator", "task", "atomic-task-numberer"]</path>
  <further_delegation>No - atomic-task-numberer doesn't delegate</further_delegation>
</delegation>
```

### Pattern 2: Two-Level Delegation

**Use Case**: Command → Subagent → Specialist

**Example**: `/research` → `researcher` → `web-research-specialist`

```xml
<delegation>
  <level_1>
    <depth>1</depth>
    <path>["orchestrator", "research", "researcher"]</path>
  </level_1>
  <level_2>
    <depth>2</depth>
    <path>["orchestrator", "research", "researcher", "web-research-specialist"]</path>
  </level_2>
</delegation>
```

### Pattern 3: Three-Level Delegation (Maximum)

**Use Case**: Command → Subagent → Specialist → Helper

**Example**: `/implement` → `task-executor` → `implementer` → `git-workflow-manager`

```xml
<delegation>
  <level_1>
    <depth>1</depth>
    <path>["orchestrator", "implement", "task-executor"]</path>
  </level_1>
  <level_2>
    <depth>2</depth>
    <path>["orchestrator", "implement", "task-executor", "implementer"]</path>
  </level_2>
  <level_3>
    <depth>3</depth>
    <path>["orchestrator", "implement", "task-executor", "implementer", "git-workflow-manager"]</path>
    <warning>Maximum depth reached - no further delegation allowed</warning>
  </level_3>
</delegation>
```

---

## Testing Delegation Safety

### Test 1: Cycle Detection

Create a scenario where delegation would create a cycle:

```python
def test_cycle_detection():
    path = ["orchestrator", "implement", "task-executor"]
    target = "task-executor"  # Already in path
    
    assert check_cycle(path, target) raises CycleError
```

**Expected**: Error returned, no infinite loop

### Test 2: Depth Limit

Create a scenario exceeding depth 3:

```python
def test_depth_limit():
    depth = 3
    
    # Try to delegate at depth 3 (would create depth 4)
    assert prepare_delegation(depth) raises DepthError
```

**Expected**: Error returned at depth 3, no delegation

### Test 3: Timeout Handling

Simulate a long-running subagent:

```python
def test_timeout():
    # Subagent that takes 7200s (2 hours)
    # Timeout set to 3600s (1 hour)
    
    result = invoke_subagent(timeout=3600, actual_duration=7200)
    
    assert result["status"] == "partial"
    assert "timeout" in result["errors"][0]["type"]
```

**Expected**: Partial status after 1 hour, not indefinite hang

### Test 4: Return Validation

Send malformed return from subagent:

```python
def test_invalid_return():
    invalid_return = {"status": "invalid_status"}  # Missing fields, invalid status
    
    assert validate_return(invalid_return) raises ValidationError
```

**Expected**: Validation error, clear message about what's wrong

---

## Troubleshooting

### Symptom: Delegation Hangs

**Cause**: Missing ReceiveResults stage or timeout not set

**Fix**:
1. Check command has ReceiveResults stage
2. Verify timeout is set (default 3600s)
3. Check subagent returns standardized format
4. Verify session_id tracking

### Symptom: Infinite Loop

**Cause**: Cycle in delegation path

**Fix**:
1. Enable cycle detection in orchestrator
2. Check delegation_path before routing
3. Verify depth limit enforced (max 3)
4. Log delegation paths for debugging

### Symptom: Timeout Too Short/Long

**Cause**: Incorrect timeout for operation type

**Fix**:
1. Adjust timeout based on operation:
   - Research: 3600s (1 hour)
   - Planning: 1800s (30 min)
   - Implementation: 7200s (2 hours)
2. Make timeout configurable per command
3. Monitor actual durations and adjust

### Symptom: Return Validation Failures

**Cause**: Subagent not following standard format

**Fix**:
1. Update subagent to follow subagent-return-format.md
2. Add validation before returning
3. Test subagent independently
4. Check session_id matches

---

## Related Documentation

- Standardized Return Format: `.opencode/context/common/standards/subagent-return-format.md`
- Task 191 Research: `.opencode/specs/191_fix_subagent_delegation_hang/reports/research-001.md`
- Task 191 Plan: `.opencode/specs/191_fix_subagent_delegation_hang/plans/implementation-001.md`
- Status Markers: `.opencode/context/common/system/status-markers.md`
