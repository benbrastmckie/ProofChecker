# Delegation Patterns and Return Format Standard

**Version**: 2.0  
**Status**: Active  
**Created**: 2025-12-29 (Task 243 Phase 3)  
**Purpose**: Unified guide for safe delegation patterns and standardized return formats

---

## Overview

This guide consolidates delegation safety patterns and return format standards to prevent delegation hangs, cycles, and timeouts. It combines guidance from:
- Task 191 delegation hang fixes (session tracking, cycle detection, timeouts)
- Standardized return format for all subagent invocations

**Problems Solved**:
- Delegation hangs (Task 191 Root Cause #1, #3)
- Infinite delegation loops (Task 191 Root Cause #2)
- Missing timeouts (Task 191 Root Cause #4)
- Coordination gaps (Task 191 Root Cause #5)
- Return format ambiguity (Task 191 Root Cause #6)

---

## Part 1: Delegation Safety Patterns

### 1. Session ID Tracking

Every delegation MUST have a unique session ID for tracking and debugging.

**Format**: `sess_{timestamp}_{random_6char}`

**Example**: `sess_20251226_abc123`

**Generation**:
```python
import time
import random
import string

def generate_session_id():
    timestamp = int(time.time())
    random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
    return f"sess_{timestamp}_{random_chars}"
```

**Usage**:
- Generated by caller before invoking subagent
- Passed to subagent in delegation context
- Returned by subagent in metadata
- Used for tracking in orchestrator registry

### 2. Delegation Depth Limits

Maximum delegation depth: **3 levels**

**Why**: Prevents infinite delegation loops and keeps system understandable.

**Depth Counting**:
- Orchestrator → Command: depth = 0 (not counted)
- Command → Subagent: depth = 1
- Subagent → Specialist: depth = 2
- Specialist → Helper: depth = 3 (max)
- Helper → Another Agent: **BLOCKED** (exceeds limit)

**Enforcement**:
- Caller increments depth before delegating
- Caller checks: `if depth >= 3: return error`
- Subagent receives depth in delegation context
- Subagent returns depth in metadata

### 3. Delegation Path Tracking

Track the full delegation path to detect cycles.

**Path Format**: Array of agent names in delegation order

**Example**: `["orchestrator", "implement", "task-executor", "implementer"]`

**Cycle Detection**:
```python
def check_cycle(delegation_path, target_agent):
    if target_agent in delegation_path:
        raise CycleError(f"Cycle detected: {delegation_path} → {target_agent}")
    return False
```

**Usage**:
- Caller appends self to path before delegating
- Caller checks if target already in path (cycle)
- Subagent receives path in delegation context
- Subagent returns path in metadata

### 4. Timeout Enforcement

All delegations MUST have timeouts to prevent indefinite hangs.

**Default Timeouts**:
- Research: 3600s (1 hour)
- Planning: 1800s (30 minutes)
- Implementation: 7200s (2 hours)
- Simple operations: 300s (5 minutes)

**Timeout Handling**:
```python
try:
    result = invoke_subagent(timeout=3600)
except TimeoutError:
    # Graceful degradation
    partial_results = check_for_artifacts()
    return {
        "status": "partial",
        "summary": "Operation timed out after 3600s",
        "artifacts": partial_results,
        "errors": [{
            "type": "timeout",
            "message": "Subagent exceeded timeout",
            "code": "TIMEOUT",
            "recoverable": true,
            "recommendation": "Resume with same command to continue"
        }]
    }
```

**Principles**:
- Never wait indefinitely
- Return partial results if available
- Mark task as IN PROGRESS (not failed)
- Provide actionable recovery message

---

## Part 2: Standard Return Format

All subagents MUST return a standardized JSON object when invoked by commands or other agents.

### Return Format Schema

```json
{
  "status": "completed|failed|partial|blocked",
  "summary": "Brief 2-5 sentence summary (max 100 tokens)",
  "artifacts": [
    {
      "type": "research|plan|implementation|summary|documentation",
      "path": "relative/path/from/project/root",
      "summary": "Optional one-sentence description"
    }
  ],
  "metadata": {
    "session_id": "unique_session_identifier",
    "duration_seconds": 123,
    "agent_type": "agent_name",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "command", "agent"]
  },
  "errors": [
    {
      "type": "timeout|validation|execution|tool_unavailable",
      "message": "Human-readable error description",
      "code": "ERROR_CODE",
      "recoverable": true,
      "recommendation": "Suggested fix or next step"
    }
  ],
  "next_steps": "Optional recommended next actions"
}
```

### Field Specifications

#### status (required)

**Type**: String enum  
**Values**: `completed` | `failed` | `partial` | `blocked`

- `completed`: All work finished successfully
- `failed`: Work failed, no usable results
- `partial`: Some work completed, partial results available (e.g., timeout)
- `blocked`: Cannot proceed, requires external resolution

**Validation**: Must be exactly one of the four values (case-sensitive)

#### summary (required)

**Type**: String  
**Length**: 2-5 sentences, max 100 tokens (approximately 400 characters)

**Guidelines**:
- Focus on outcomes, not process
- Be specific about what was created or changed
- Mention key decisions or blockers
- No emojis or formatting markup

**Example**: "Created implementation plan for task 191 with 3 phases. Plan addresses 6 root causes of delegation hangs through explicit return handling, cycle detection, and timeout mechanisms. Estimated 14 hours total effort."

#### artifacts (required, can be empty array)

**Type**: Array of artifact objects

**Artifact Object**:
```json
{
  "type": "research|plan|implementation|summary|documentation",
  "path": "relative/path/from/root",
  "summary": "Optional one-sentence description"
}
```

**Validation**:
- Paths must be relative from project root
- All paths must exist or be created during execution
- Type must match artifact purpose

#### metadata (required)

**Type**: Object with required fields

**Required Fields**:
- `session_id`: Unique identifier for this delegation (format: `sess_{timestamp}_{random}`)
- `duration_seconds`: Execution time in seconds
- `agent_type`: Name of the agent returning results
- `delegation_depth`: Current depth in delegation chain (prevents cycles)
- `delegation_path`: Array of agent names in delegation chain

**Purpose**: Enables cycle detection and delegation tracking

#### errors (optional, empty array if no errors)

**Type**: Array of error objects

**Error Object**:
```json
{
  "type": "timeout|validation|execution|tool_unavailable",
  "message": "Human-readable description",
  "code": "ERROR_CODE",
  "recoverable": true,
  "recommendation": "Suggested fix"
}
```

**When to Include**:
- Status is `failed` or `partial`: MUST include errors
- Status is `blocked`: MUST include error explaining blocker
- Status is `completed`: errors array should be empty

#### next_steps (optional)

**Type**: String (1-2 sentences)

**When to Include**:
- Recommend follow-up actions
- Suggest alternative approaches after failure
- Indicate dependencies or prerequisites

---

## Part 3: Standard Delegation Pattern

All commands that invoke subagents MUST follow this pattern:

### Stage 1: Prepare Delegation

```xml
<stage id="N" name="PrepareDelegation">
  <action>Prepare delegation context</action>
  <process>
    1. Generate unique session_id
    2. Get current delegation_depth from context (default 0)
    3. Get current delegation_path from context (default [])
    4. Increment depth: new_depth = depth + 1
    5. Check depth limit: if new_depth >= 3: return error
    6. Append self to path: new_path = path + [self_name]
    7. Check for cycles: if target in new_path: return error
    8. Determine timeout based on operation type
    9. Store session_id for later validation
  </process>
  <delegation_context>
    {
      "session_id": "sess_20251226_abc123",
      "delegation_depth": 1,
      "delegation_path": ["orchestrator", "implement"],
      "timeout": 3600
    }
  </delegation_context>
</stage>
```

### Stage 2: Invoke Subagent

```xml
<stage id="N+1" name="InvokeSubagent">
  <action>Invoke subagent with delegation context</action>
  <process>
    1. Route to appropriate subagent
    2. Pass delegation context
    3. Pass task-specific parameters
    4. Set timeout from delegation context
    5. Begin monitoring (if orchestrator)
  </process>
  <invocation>
    task_tool(
      subagent_type="researcher",
      prompt="Research topic: {topic}",
      session_id=delegation_context["session_id"],
      delegation_depth=delegation_context["delegation_depth"],
      delegation_path=delegation_context["delegation_path"],
      timeout=delegation_context["timeout"]
    )
  </invocation>
</stage>
```

### Stage 3: Receive Results

```xml
<stage id="N+2" name="ReceiveResults">
  <action>Wait for and receive subagent results</action>
  <process>
    1. Poll for completion (max timeout seconds)
    2. Receive return object from subagent
    3. Handle timeout if no response
    4. Handle exceptions if invocation failed
  </process>
  <timeout_handling>
    If timeout (no response after {timeout}s):
      1. Log timeout error with session_id
      2. Check for partial artifacts on disk
      3. Return partial status with artifacts found
      4. Provide recovery message
      5. Do NOT mark task as failed
  </timeout_handling>
  <exception_handling>
    If exception during invocation:
      1. Log exception with stack trace
      2. Return failed status
      3. Provide actionable error message
      4. Recommend troubleshooting steps
  </exception_handling>
</stage>
```

### Stage 4: Validate Return

```xml
<stage id="N+3" name="ValidateReturn">
  <action>Validate return against standard format</action>
  <process>
    1. Validate JSON structure
    2. Validate against Part 2 schema (Standard Return Format)
    3. Check session_id matches expected
    4. Validate all required fields present
    5. Validate status is valid enum
    6. Validate summary within length limits
    7. Validate artifacts have valid paths
  </process>
  <validation_failure>
    If validation fails:
      1. Log validation error with details
      2. Return failed status
      3. Include original return for debugging
      4. Recommend subagent fix
  </validation_failure>
</stage>
```

### Stage 5: Process Results

```xml
<stage id="N+4" name="ProcessResults">
  <action>Extract and process validated results</action>
  <process>
    1. Extract status from return
    2. Extract summary for user/caller
    3. Extract artifacts for linking
    4. Extract errors if status != completed
    5. Extract next_steps if present
    6. Prepare for next stage (postflight/return)
  </process>
  <status_handling>
    If status == "completed":
      - All work finished successfully
      - Proceed to postflight with artifacts
    If status == "partial":
      - Some work completed
      - Keep task IN PROGRESS
      - Save partial results
    If status == "failed":
      - No usable results
      - Handle errors
      - Provide recovery steps
    If status == "blocked":
      - Cannot proceed
      - Identify blocker
      - Request user intervention
  </status_handling>
</stage>
```

---

## Part 4: Validation Requirements

### Return Validation Checklist

All subagents MUST validate their return before sending:

1. **Required fields present**: status, summary, artifacts, metadata
2. **Status is valid enum**: One of the four allowed values
3. **Summary within limits**: 2-5 sentences, max 100 tokens
4. **Artifacts valid**: All paths exist, types match
5. **Metadata complete**: session_id, duration, agent_type, delegation info
6. **Errors match status**: If failed/partial/blocked, errors present

**Validation Failure**: If validation fails, return a `failed` status with error explaining validation failure.

### Delegation Safety Validation

```python
def validate_return(return_obj, expected_session_id):
    # 1. Check JSON structure
    assert isinstance(return_obj, dict), "Return must be JSON object"
    
    # 2. Check required fields
    required = ["status", "summary", "artifacts", "metadata"]
    for field in required:
        assert field in return_obj, f"Missing required field: {field}"
    
    # 3. Validate status
    valid_statuses = ["completed", "failed", "partial", "blocked"]
    assert return_obj["status"] in valid_statuses, f"Invalid status: {return_obj['status']}"
    
    # 4. Check session ID
    actual_session = return_obj["metadata"]["session_id"]
    assert actual_session == expected_session_id, f"Session ID mismatch: {actual_session} != {expected_session_id}"
    
    # 5. Validate summary length
    summary = return_obj["summary"]
    assert len(summary) > 0, "Summary cannot be empty"
    assert len(summary) <= 500, "Summary too long (max 500 chars)"
    
    return True
```

---

## Part 5: Error Codes and Handling

### Standardized Error Codes

- `TIMEOUT`: Operation exceeded time limit
- `VALIDATION_FAILED`: Input validation failed
- `TOOL_UNAVAILABLE`: Required tool (lean-lsp-mcp, etc.) not available
- `BUILD_ERROR`: Compilation or build failed
- `FILE_NOT_FOUND`: Required file missing
- `CYCLE_DETECTED`: Delegation would create cycle
- `MAX_DEPTH_EXCEEDED`: Delegation depth limit (3) exceeded
- `STATUS_SYNC_FAILED`: Failed to update .opencode/specs/TODO.md/state.json
- `GIT_COMMIT_FAILED`: Failed to create git commit
- `UNKNOWN_ERROR`: Unexpected error occurred

### Error Propagation

Errors MUST propagate up the delegation chain:

**Subagent Error**:
```json
{
  "status": "failed",
  "summary": "Implementation failed due to build errors",
  "artifacts": [],
  "errors": [{
    "type": "build_error",
    "message": "Lean file compilation failed: 3 type errors",
    "code": "BUILD_ERROR",
    "recoverable": true,
    "recommendation": "Fix type errors and retry"
  }],
  "metadata": {
    "session_id": "sess_20251226_abc123",
    "agent_type": "implementer"
  }
}
```

**Command Handling**:
```python
def handle_error_return(return_obj):
    errors = return_obj["errors"]
    
    # Log to errors.json
    for error in errors:
        log_error({
            "type": error["type"],
            "message": error["message"],
            "code": error["code"],
            "context": {
                "command": current_command,
                "task_number": current_task,
                "session_id": return_obj["metadata"]["session_id"]
            }
        })
    
    # Check if recoverable
    if all(e["recoverable"] for e in errors):
        return f"Task failed but is recoverable. {errors[0]['recommendation']}"
    else:
        return f"Task failed. Manual intervention required: {errors[0]['message']}"
```

---

## Part 6: Common Delegation Patterns

### Pattern 1: Simple Delegation (No Further Delegation)

**Use Case**: Command → Subagent (subagent does work directly)

**Example**: `/task` → `atomic-task-numberer`

```xml
<delegation>
  <depth>1</depth>
  <path>["orchestrator", "task", "atomic-task-numberer"]</path>
  <further_delegation>No - atomic-task-numberer doesn't delegate</further_delegation>
</delegation>
```

### Pattern 2: Two-Level Delegation

**Use Case**: Command → Subagent → Specialist

**Example**: `/research` → `researcher` → `web-research-specialist`

```xml
<delegation>
  <level_1>
    <depth>1</depth>
    <path>["orchestrator", "research", "researcher"]</path>
  </level_1>
  <level_2>
    <depth>2</depth>
    <path>["orchestrator", "research", "researcher", "web-research-specialist"]</path>
  </level_2>
</delegation>
```

### Pattern 3: Three-Level Delegation (Maximum)

**Use Case**: Command → Subagent → Specialist → Helper

**Example**: `/implement` → `task-executor` → `implementer` → `git-workflow-manager`

```xml
<delegation>
  <level_1>
    <depth>1</depth>
    <path>["orchestrator", "implement", "task-executor"]</path>
  </level_1>
  <level_2>
    <depth>2</depth>
    <path>["orchestrator", "implement", "task-executor", "implementer"]</path>
  </level_2>
  <level_3>
    <depth>3</depth>
    <path>["orchestrator", "implement", "task-executor", "implementer", "git-workflow-manager"]</path>
    <warning>Maximum depth reached - no further delegation allowed</warning>
  </level_3>
</delegation>
```

---

## Part 7: Examples

### Successful Research Completion

```json
{
  "status": "completed",
  "summary": "Research completed on LeanExplore, Loogle, and LeanSearch integration. Found official APIs for all three tools. LeanExplore uses HTTP API, Loogle has CLI interface, LeanSearch provides REST endpoints. Recommend REST API integration for LeanSearch first.",
  "artifacts": [
    {
      "type": "research",
      "path": ".opencode/specs/195_lean_tools_research/reports/research-001.md",
      "summary": "Detailed API specifications for all three Lean tools"
    },
    {
      "type": "summary",
      "path": ".opencode/specs/195_lean_tools_research/summaries/research-summary.md",
      "summary": "Key findings and integration recommendations"
    }
  ],
  "metadata": {
    "session_id": "sess_20251226_abc123",
    "duration_seconds": 1250,
    "agent_type": "researcher",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "research-command", "researcher"]
  },
  "errors": [],
  "next_steps": "Create implementation plan for LeanSearch REST API integration"
}
```

### Partial Completion (Timeout)

```json
{
  "status": "partial",
  "summary": "Implementation of task 191 phase 1 started but timed out after 1 hour. Successfully completed return format standardization and updated /implement command. Remaining work: update /research and /plan commands with return handling.",
  "artifacts": [
    {
      "type": "implementation",
      "path": ".opencode/context/common/workflows/delegation-patterns.md",
      "summary": "Standardized delegation and return format specification"
    },
    {
      "type": "implementation",
      "path": ".opencode/command/implement.md",
      "summary": "Updated with ReceiveResults and ProcessResults stages"
    }
  ],
  "metadata": {
    "session_id": "sess_20251226_def456",
    "duration_seconds": 3600,
    "agent_type": "implementer",
    "delegation_depth": 2,
    "delegation_path": ["orchestrator", "implement-command", "task-executor", "implementer"]
  },
  "errors": [
    {
      "type": "timeout",
      "message": "Implementation exceeded 3600s timeout",
      "code": "TIMEOUT",
      "recoverable": true,
      "recommendation": "Run /implement 191 again to resume from phase 2"
    }
  ],
  "next_steps": "Resume implementation by running /implement 191"
}
```

### Failed Execution

```json
{
  "status": "failed",
  "summary": "Failed to implement Lean proof due to lean-lsp-mcp unavailability. Checked .mcp.json configuration and attempted fallback to direct Lean compilation. Both approaches failed.",
  "artifacts": [],
  "metadata": {
    "session_id": "sess_20251226_ghi789",
    "duration_seconds": 45,
    "agent_type": "lean-implementation-agent",
    "delegation_depth": 1,
    "delegation_path": ["orchestrator", "implement-command", "lean-implementation-agent"]
  },
  "errors": [
    {
      "type": "tool_unavailable",
      "message": "lean-lsp-mcp not available in .mcp.json",
      "code": "TOOL_UNAVAILABLE",
      "recoverable": true,
      "recommendation": "Install lean-lsp-mcp: uvx lean-lsp-mcp"
    }
  ],
  "next_steps": "Install lean-lsp-mcp and retry implementation"
}
```

---

## Part 8: Troubleshooting

### Symptom: Delegation Hangs

**Cause**: Missing ReceiveResults stage or timeout not set

**Fix**:
1. Check command has ReceiveResults stage
2. Verify timeout is set (default 3600s)
3. Check subagent returns standardized format
4. Verify session_id tracking

### Symptom: Infinite Loop

**Cause**: Cycle in delegation path

**Fix**:
1. Enable cycle detection in orchestrator
2. Check delegation_path before routing
3. Verify depth limit enforced (max 3)
4. Log delegation paths for debugging

### Symptom: Timeout Too Short/Long

**Cause**: Incorrect timeout for operation type

**Fix**:
1. Adjust timeout based on operation:
   - Research: 3600s (1 hour)
   - Planning: 1800s (30 min)
   - Implementation: 7200s (2 hours)
2. Make timeout configurable per command
3. Monitor actual durations and adjust

### Symptom: Return Validation Failures

**Cause**: Subagent not following standard format

**Fix**:
1. Update subagent to follow Part 2 (Standard Return Format)
2. Add validation before returning
3. Test subagent independently
4. Check session_id matches

---

## Related Documentation

- Command Lifecycle: `.opencode/context/common/workflows/command-lifecycle.md`
- State Management: `.opencode/context/common/system/state-management.md`
- Task 191 Research: `.opencode/specs/191_fix_subagent_delegation_hang/reports/research-001.md`
- Task 191 Plan: `.opencode/specs/191_fix_subagent_delegation_hang/plans/implementation-001.md`
