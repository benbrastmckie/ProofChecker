{
  "metadata": {
    "report_date": "2025-12-21",
    "report_type": "Loogle Bounded Computation Pattern Search",
    "target_pattern": "Nat → α → Option α (and variants)",
    "libraries_searched": ["Init", "Std", "Mathlib", "Lean", "Batteries", "Aesop"],
    "total_functions_analyzed": 400
  },
  "search_queries": {
    "successful": [
      {
        "query": "Nat → _ → Option _",
        "matches": 114,
        "status": "success"
      },
      {
        "query": "_ → Nat → Option _",
        "matches": 92,
        "status": "success"
      },
      {
        "query": "fuel (keyword)",
        "matches": 14,
        "status": "success"
      },
      {
        "query": "runFor (keyword)",
        "matches": 1,
        "status": "success"
      },
      {
        "query": "evaln (keyword)",
        "matches": 18,
        "status": "success"
      },
      {
        "query": "iterate (keyword)",
        "matches": 552,
        "status": "success",
        "note": "Limited to first 200 results"
      },
      {
        "query": "WellFounded (keyword)",
        "matches": 165,
        "status": "success"
      }
    ],
    "failed": [
      {
        "query": "Nat → α → Option α",
        "status": "error",
        "reason": "Type variable α not recognized by Loogle"
      },
      {
        "query": "α → Nat → Option α",
        "status": "error",
        "reason": "Type variable α not recognized by Loogle"
      },
      {
        "query": "Nat → α → α",
        "status": "timeout",
        "reason": "Pattern too general"
      }
    ]
  },
  "exact_matches": [
    {
      "name": "Computation.runFor",
      "type": "{α : Type u} : Computation α → ℕ → Option α",
      "library": "Mathlib",
      "module": "Mathlib.Data.Seq.Computation",
      "category": "fuel_based_execution",
      "description": "Evaluates computation for n steps, returns result or none if not terminated",
      "bounded_semantics": "Classic fuel pattern - fuel controls max evaluation steps",
      "relevance_score": 10
    },
    {
      "name": "Nat.Partrec.Code.evaln",
      "type": "ℕ → Nat.Partrec.Code → ℕ → Option ℕ",
      "library": "Mathlib",
      "module": "Mathlib.Computability.PartrecCode",
      "category": "fuel_based_execution",
      "description": "Bounded evaluation for partial recursive functions with soundness/completeness",
      "bounded_semantics": "Fuel k bounds intermediate values - fails if value ≥ k encountered",
      "key_theorems": ["evaln_sound", "evaln_complete", "evaln_mono", "eval_eq_rfindOpt"],
      "relevance_score": 10
    },
    {
      "name": "Std.Iterators.Iter.atIdxSlow?",
      "type": "{α β : Type u_1} [Iterator α Id β] [Productive α Id] (n : ℕ) (it : Iter β) : Option β",
      "library": "Std",
      "module": "Init.Data.Iterators.Consumers.Access",
      "category": "iterator_access",
      "description": "Takes n steps with iterator, returns nth value or none if finished",
      "bounded_semantics": "n bounds number of iterator steps",
      "relevance_score": 8
    },
    {
      "name": "Std.Iterators.Iter.atIdx?",
      "type": "{α β : Type u_1} [Iterator α Id β] [Productive α Id] [IteratorAccess α Id] (n : ℕ) (it : Iter β) : Option β",
      "library": "Std",
      "module": "Init.Data.Iterators.Consumers.Access",
      "category": "iterator_access",
      "description": "Returns nth value with optimized access (may take shortcuts)",
      "bounded_semantics": "n bounds result position, actual steps may be fewer",
      "relevance_score": 8
    },
    {
      "name": "Lean.Elab.Tactic.Do.Fuel",
      "type": "Type",
      "library": "Lean",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "category": "fuel_type_system",
      "description": "Type-safe fuel for do-notation verification",
      "constructors": ["Fuel.unlimited", "Fuel.limited (n : ℕ)"],
      "bounded_semantics": "Type-level fuel representation",
      "relevance_score": 9
    },
    {
      "name": "List.get?Internal",
      "type": "{α : Type u_1} (as : List α) (i : ℕ) : Option α",
      "library": "Init",
      "module": "Init.GetElem",
      "category": "index_access",
      "description": "Internal implementation of list indexing",
      "bounded_semantics": "Index i bounds position in list",
      "relevance_score": 6
    },
    {
      "name": "Array.get?",
      "type": "{α : Type u_1} (as : Array α) (i : ℕ) : Option α",
      "library": "Init",
      "module": "Init.Data.Array.Basic",
      "category": "index_access",
      "description": "Safe array indexing with bounds checking",
      "bounded_semantics": "Index i bounds position in array",
      "relevance_score": 6
    },
    {
      "name": "TreeMap.keyAtIdx?",
      "type": "{α β : Type} {cmp : α → α → Ordering} (t : TreeMap α β cmp) (n : ℕ) : Option α",
      "library": "Std",
      "module": "Std.Data.TreeMap.Basic",
      "category": "index_access",
      "description": "Returns nth smallest key or none if n ≥ size",
      "bounded_semantics": "Index n bounds position in ordered map",
      "relevance_score": 7
    },
    {
      "name": "BitVec.getLsb?",
      "type": "{w : ℕ} (x : BitVec w) (i : ℕ) : Option Bool",
      "library": "Init",
      "module": "Init.Data.BitVec.Basic",
      "category": "index_access",
      "description": "Returns ith least significant bit or none if i ≥ w",
      "bounded_semantics": "Index i bounds bit position",
      "relevance_score": 5
    },
    {
      "name": "Encodable.decode",
      "type": "{α : Type u_1} [Encodable α] : ℕ → Option α",
      "library": "Mathlib",
      "module": "Mathlib.Logic.Encodable.Basic",
      "category": "encoding_decoding",
      "description": "Decoding from ℕ to Option α",
      "bounded_semantics": "Nat encodes element, decode attempts recovery",
      "relevance_score": 7
    }
  ],
  "pattern_categories": {
    "fuel_based_execution": {
      "count": 3,
      "description": "Nat parameter controls execution steps/depth",
      "examples": ["Computation.runFor", "Nat.Partrec.Code.evaln", "Lean.Elab.Tactic.Do.Fuel"],
      "use_cases": ["Non-terminating computations", "Performance testing", "Decidable approximations"]
    },
    "index_access": {
      "count": 40,
      "description": "Nat parameter specifies position in collection",
      "examples": ["List.get?", "Array.get?", "TreeMap.keyAtIdx?", "Ordnode.nth"],
      "use_cases": ["Safe collection access", "Bounds-checked indexing", "Ordered structure traversal"]
    },
    "iterator_access": {
      "count": 10,
      "description": "Nat parameter controls iterator advancement",
      "examples": ["Iter.atIdxSlow?", "Iter.atIdx?", "UpwardEnumerable.succMany?"],
      "use_cases": ["Lazy sequence access", "Incremental computation", "Stream processing"]
    },
    "encoding_decoding": {
      "count": 15,
      "description": "Nat parameter represents encoded value",
      "examples": ["Encodable.decode", "Encodable.decode₂"],
      "use_cases": ["Generic serialization", "Bijective encodings", "Computability theory"]
    },
    "well_founded_recursion": {
      "count": 165,
      "description": "Structural bounds via well-founded relations",
      "examples": ["WellFounded.fix", "WellFounded.fixC", "Productive.wf"],
      "use_cases": ["Verified total functions", "Termination proofs", "Type-level guarantees"]
    }
  },
  "library_distribution": {
    "Init": {
      "matches": 45,
      "notable_patterns": ["Iterator access", "BitVec", "ByteArray", "Basic collections"]
    },
    "Std": {
      "matches": 30,
      "notable_patterns": ["Tree maps/sets", "Time bounds", "BVDecide fuel"]
    },
    "Mathlib": {
      "matches": 80,
      "notable_patterns": ["Computability theory", "Encodables", "Sequences", "Ordinals"]
    },
    "Lean": {
      "matches": 15,
      "notable_patterns": ["Do-notation fuel", "Edit distance", "Metaprogramming"]
    },
    "Batteries": {
      "matches": 8,
      "notable_patterns": ["List utilities", "Fin operations"]
    },
    "Aesop": {
      "matches": 2,
      "notable_patterns": ["Script manipulation"]
    }
  },
  "key_insights": [
    "Lean uses THREE distinct bounded computation paradigms: explicit fuel, index bounds, and structural bounds",
    "Mathlib.Computability provides formal treatment with soundness/completeness theorems",
    "Std.Iterators innovates with type-level termination witnesses (Productive/Finite)",
    "WellFounded recursion eliminates need for explicit fuel in many cases",
    "evaln pattern demonstrates decidable approximation of undecidable problems",
    "Iterator framework separates iteration logic from termination proofs"
  ],
  "recommendations": {
    "for_proof_search": [
      "Use Computation.runFor pattern for fuel-based proof search",
      "Implement progressive deepening with increasing fuel",
      "Provide both bounded and unbounded variants",
      "Include fuel monotonicity theorems"
    ],
    "for_tactic_development": [
      "Consider WellFounded recursion for structural tactics",
      "Use Iterator framework for incremental tactic application",
      "Leverage Productive witnesses for termination guarantees"
    ],
    "for_modal_logic": [
      "Modal depth provides natural well-founded metric",
      "No explicit fuel needed for depth-bounded search",
      "Can combine with fuel for non-structural strategies"
    ]
  },
  "related_patterns": {
    "function_iteration": {
      "signature": "Nat.iterate : {α : Sort u} (op : α → α) → ℕ → α → α",
      "description": "Iterate function n times",
      "notation": "f^[n]",
      "use_case": "Fuel in result type rather than Option"
    },
    "partial_functions": {
      "signature": "Part α - partial computation monad",
      "description": "Computations that may not terminate",
      "use_case": "Unbounded computation with termination proofs"
    },
    "bounded_types": {
      "signature": "Bounded.LE lo hi - bounded integers",
      "description": "Values provably in range",
      "use_case": "Static bounds rather than runtime checks"
    }
  }
}
