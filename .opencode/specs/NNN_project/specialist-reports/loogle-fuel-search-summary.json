{
  "search_pattern": "fuel",
  "search_date": "2025-12-21",
  "matches_count": 38,
  "report_path": ".opencode/specs/NNN_project/specialist-reports/loogle-fuel-search.md",
  "api_endpoint": "https://loogle.lean-lang.org/json?q=%22fuel%22",
  "heartbeats": 1,
  
  "exact_matches": [
    {
      "name": "Lean.Elab.Tactic.Do.Fuel",
      "type": "Type",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Lean.Elab.Tactic.Do.Fuel.unlimited",
      "type": "Lean.Elab.Tactic.Do.Fuel",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Lean.Elab.Tactic.Do.Fuel.limited",
      "type": "(n : ℕ) : Lean.Elab.Tactic.Do.Fuel",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Lean.Elab.Tactic.Do.State.fuel",
      "type": "(self : Lean.Elab.Tactic.Do.State) : Lean.Elab.Tactic.Do.Fuel",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Lean.Elab.Tactic.Do.ifOutOfFuel",
      "type": "{α : Type} (x k : Lean.Elab.Tactic.Do.VCGenM α) : Lean.Elab.Tactic.Do.VCGenM α",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Lean.Elab.Tactic.Do.VCGen.genVCs",
      "type": "(goal : Lean.MVarId) (ctx : Lean.Elab.Tactic.Do.Context) (fuel : Lean.Elab.Tactic.Do.Fuel) : Lean.MetaM Lean.Elab.Tactic.Do.VCGen.Result",
      "library": "Lean Core",
      "module": "Lean.Elab.Tactic.Do.VCGen",
      "documentation": null,
      "category": "core_infrastructure"
    },
    {
      "name": "Nat.div_rec_fuel_lemma",
      "type": "{x y fuel : ℕ} (hy : 0 < y) (hle : y ≤ x) (hfuel : x < fuel + 1) : x - y < fuel",
      "library": "Lean Init",
      "module": "Init.Prelude",
      "documentation": null,
      "category": "termination_proof"
    },
    {
      "name": "Lean.Grind.CommRing.hugeFuel",
      "type": "ℕ",
      "library": "Lean Init",
      "module": "Init.Grind.Ring.CommSolver",
      "documentation": null,
      "category": "fuel_constant"
    },
    {
      "name": "Lean.Grind.CommRing.Mon.revlexFuel",
      "type": "(fuel : ℕ) (m₁ m₂ : Lean.Grind.CommRing.Mon) : Ordering",
      "library": "Lean Init",
      "module": "Init.Grind.Ring.CommSolver",
      "documentation": null,
      "category": "fuel_recursion"
    },
    {
      "name": "Lean.Grind.CommRing.Mon.eq_of_revlexFuel",
      "type": "{fuel : ℕ} {m₁ m₂ : Lean.Grind.CommRing.Mon} : Lean.Grind.CommRing.Mon.revlexFuel fuel m₁ m₂ = Ordering.eq → m₁ = m₂",
      "library": "Lean Init",
      "module": "Init.Grind.Ring.CommSolver",
      "documentation": null,
      "category": "fuel_correctness"
    },
    {
      "name": "Lean.Grind.AC.hugeFuel",
      "type": "ℕ",
      "library": "Lean Init",
      "module": "Init.Grind.AC",
      "documentation": null,
      "category": "fuel_constant"
    },
    {
      "name": "Lean.Grind.AC.Seq.unionFuel",
      "type": "(fuel : ℕ) (s₁ s₂ : Lean.Grind.AC.Seq) : Lean.Grind.AC.Seq",
      "library": "Lean Init",
      "module": "Init.Grind.AC",
      "documentation": null,
      "category": "fuel_recursion"
    },
    {
      "name": "Lean.Grind.AC.Seq.denote_unionFuel",
      "type": "{α : Sort u_1} (ctx : Lean.Grind.AC.Context α) {inst₁ : Std.Associative ctx.op} {inst₂ : Std.Commutative ctx.op} (fuel : ℕ) (s₁ s₂ : Lean.Grind.AC.Seq) : Lean.Grind.AC.Seq.denote ctx (Lean.Grind.AC.Seq.unionFuel fuel s₁ s₂) = ctx.op (Lean.Grind.AC.Seq.denote ctx s₁) (Lean.Grind.AC.Seq.denote ctx s₂)",
      "library": "Lean Init",
      "module": "Init.Grind.AC",
      "documentation": null,
      "category": "fuel_correctness"
    },
    {
      "name": "Nat.Linear.hugeFuel",
      "type": "ℕ",
      "library": "Lean Init",
      "module": "Init.Data.Nat.Linear",
      "documentation": null,
      "category": "fuel_constant"
    },
    {
      "name": "Int.Linear.hugeFuel",
      "type": "ℕ",
      "library": "Lean Init",
      "module": "Init.Data.Int.Linear",
      "documentation": null,
      "category": "fuel_constant"
    },
    {
      "name": "Lean.Meta.Contradiction.Config.searchFuel",
      "type": "(self : Lean.Meta.Contradiction.Config) : ℕ",
      "library": "Lean Core",
      "module": "Lean.Meta.Tactic.Contradiction",
      "documentation": "When checking for empty types, `searchFuel` specifies the number of goals visited.",
      "category": "search_bound"
    },
    {
      "name": "Plausible.Gen.Gen.outOfFuel",
      "type": "Plausible.GenError",
      "library": "Lean Std",
      "module": "Plausible.Gen",
      "documentation": "Raised when a fueled generator fails due to insufficient fuel.",
      "category": "error_handling"
    },
    {
      "name": "Plausible.ArbitraryFueled",
      "type": "(α : Type) : Type",
      "library": "Lean Std",
      "module": "Plausible.ArbitraryFueled",
      "documentation": "A typeclass for *fueled* random generation, i.e. a variant of the `Arbitrary` typeclass where the fuel for the generator is made explicit. This typeclass is equivalent to Rocq QuickChick's `arbitrarySized` typeclass (QuickChick uses the `Nat` parameter as both fuel and the generator size, here we use it just for fuel, as Plausible's `Gen` type constructor already internalizes the size parameter.)",
      "category": "typeclass"
    },
    {
      "name": "Plausible.ArbitraryFueled.arbitraryFueled",
      "type": "{α : Type} [self : Plausible.ArbitraryFueled α] : ℕ → Plausible.Gen α",
      "library": "Lean Std",
      "module": "Plausible.ArbitraryFueled",
      "documentation": "Takes a `Nat` and produces a random generator dependent on the `Nat` parameter (which indicates the amount of fuel to be used before failing).",
      "category": "typeclass_method"
    },
    {
      "name": "Plausible.instArbitraryOfArbitraryFueled",
      "type": "{α : Type} [Plausible.ArbitraryFueled α] : Plausible.Arbitrary α",
      "library": "Lean Std",
      "module": "Plausible.ArbitraryFueled",
      "documentation": "Every `ArbitraryFueled` instance gives rise to an `Arbitrary` instance",
      "category": "typeclass_instance"
    }
  ],
  
  "categorized_results": {
    "fuel_recursion": [
      {
        "name": "Lean.Elab.Tactic.Do.Fuel",
        "description": "Core ADT for fuel-based computation with limited/unlimited variants",
        "module": "Lean.Elab.Tactic.Do.VCGen.Basic",
        "usage": "Verification condition generation in do-tactic"
      },
      {
        "name": "Lean.Grind.CommRing.Mon.revlexFuel",
        "description": "Reverse lexicographic ordering with fuel-bounded recursion",
        "module": "Init.Grind.Ring.CommSolver",
        "usage": "Commutative ring monomial comparison"
      },
      {
        "name": "Lean.Grind.AC.Seq.unionFuel",
        "description": "Fuel-bounded union of AC sequences",
        "module": "Init.Grind.AC",
        "usage": "Associative-commutative matching in Grind tactic"
      },
      {
        "name": "Nat.div_rec_fuel_lemma",
        "description": "Termination proof for division recursion",
        "module": "Init.Prelude",
        "usage": "Natural number division well-foundedness"
      }
    ],
    
    "termination_related": [
      {
        "name": "Nat.div_rec_fuel_lemma",
        "description": "Proves fuel decreases in division recursion",
        "pattern": "structural_recursion_with_fuel"
      },
      {
        "name": "Lean.Grind.CommRing.Mon.revlexFuel",
        "description": "Fuel-based termination for monomial ordering",
        "pattern": "fuel_with_wf_fallback"
      },
      {
        "name": "Lean.Grind.AC.Seq.unionFuel",
        "description": "Fuel-bounded sequence union ensures termination",
        "pattern": "fuel_with_correctness_proof"
      }
    ],
    
    "bounded_computation": [
      {
        "name": "Lean.Meta.Contradiction.Config.searchFuel",
        "description": "Bounds contradiction search depth",
        "use_case": "Prevent infinite loops in proof search"
      },
      {
        "name": "Plausible.ArbitraryFueled.arbitraryFueled",
        "description": "Fuel-bounded random generation",
        "use_case": "Property-based testing with complexity bounds"
      },
      {
        "name": "Lean.Elab.Tactic.Do.VCGen.genVCs",
        "description": "Bounded verification condition generation",
        "use_case": "Symbolic execution with depth limits"
      }
    ],
    
    "fuel_constants": [
      {
        "name": "Lean.Grind.CommRing.hugeFuel",
        "module": "Init.Grind.Ring.CommSolver",
        "purpose": "Default large fuel for ring solver"
      },
      {
        "name": "Lean.Grind.AC.hugeFuel",
        "module": "Init.Grind.AC",
        "purpose": "Default large fuel for AC matching"
      },
      {
        "name": "Nat.Linear.hugeFuel",
        "module": "Init.Data.Nat.Linear",
        "purpose": "Default fuel for Nat linear arithmetic"
      },
      {
        "name": "Int.Linear.hugeFuel",
        "module": "Init.Data.Int.Linear",
        "purpose": "Default fuel for Int linear arithmetic"
      }
    ],
    
    "correctness_theorems": [
      {
        "name": "Lean.Grind.CommRing.Mon.eq_of_revlexFuel",
        "statement": "Ordering.eq implies monomial equality (fuel-independent)",
        "significance": "Proves fuel doesn't affect correctness"
      },
      {
        "name": "Lean.Grind.AC.Seq.denote_unionFuel",
        "statement": "Fuel-bounded union preserves semantic meaning",
        "significance": "Fuel is purely for termination, not semantics"
      }
    ],
    
    "other_matches": [
      {
        "name": "Lean.Elab.Tactic.Do.instDecidableEqFuel",
        "category": "typeclass_instance",
        "purpose": "Decidable equality for Fuel type"
      },
      {
        "name": "Lean.Elab.Tactic.Do.Fuel.ctorElimType",
        "category": "metaprogramming",
        "purpose": "Constructor elimination helper"
      },
      {
        "name": "Plausible.Gen.Gen.outOfFuel",
        "category": "error_type",
        "purpose": "Fuel exhaustion error for generators"
      }
    ]
  },
  
  "library_distribution": {
    "Lean Init": 27,
    "Lean Core": 9,
    "Lean Std": 5,
    "Mathlib": 0,
    "Batteries": 0
  },
  
  "module_distribution": {
    "Lean.Elab.Tactic.Do.VCGen.Basic": 11,
    "Init.Grind.Ring.CommSolver": 9,
    "Init.Grind.AC": 7,
    "Plausible.ArbitraryFueled": 3,
    "Init.Prelude": 1,
    "Init.Data.Nat.Linear": 1,
    "Init.Data.Int.Linear": 1,
    "Lean.Meta.Tactic.Contradiction": 1,
    "Plausible.Gen": 1,
    "Lean.Elab.Tactic.Do.VCGen": 1
  },
  
  "design_patterns": {
    "adt_based_fuel": {
      "pattern": "inductive Fuel where | unlimited | limited (n : Nat)",
      "example": "Lean.Elab.Tactic.Do.Fuel",
      "benefits": ["Type-level distinction", "Flexible configuration", "Explicit unbounded case"]
    },
    
    "huge_fuel_constant": {
      "pattern": "def hugeFuel : Nat := <large_value>",
      "examples": ["Lean.Grind.CommRing.hugeFuel", "Nat.Linear.hugeFuel"],
      "benefits": ["Simple API", "No Option wrapper", "Practically unlimited"]
    },
    
    "fuel_with_wf_fallback": {
      "pattern": "match fuel with | 0 => wf_recursion | n+1 => fuel_recursion n",
      "example": "Lean.Grind.CommRing.Mon.revlexFuel.eq_1",
      "benefits": ["Correctness guarantee", "Performance optimization", "Hybrid approach"]
    },
    
    "correctness_independence": {
      "pattern": "theorem denote_fuel : denote (fuel_fn fuel x) = denote (fuel_fn fuel' x)",
      "example": "Lean.Grind.AC.Seq.denote_unionFuel",
      "benefits": ["Fuel for termination only", "Semantic preservation", "Soundness"]
    },
    
    "monadic_fuel_management": {
      "pattern": "ifOutOfFuel : VCGenM α → VCGenM α → VCGenM α",
      "example": "Lean.Elab.Tactic.Do.ifOutOfFuel",
      "benefits": ["Clean error handling", "State threading", "Composability"]
    },
    
    "typeclass_based_fuel": {
      "pattern": "class ArbitraryFueled (α : Type) where arbitraryFueled : Nat → Gen α",
      "example": "Plausible.ArbitraryFueled",
      "benefits": ["Type-driven generation", "Composable instances", "Automatic derivation"]
    }
  },
  
  "key_insights": [
    "Fuel is primarily used for termination, not correctness",
    "Lean's standard library extensively uses fuel in decision procedures and tactics",
    "The Fuel ADT pattern (limited/unlimited) provides flexibility without complexity",
    "Huge fuel constants provide practical 'infinity' without performance overhead",
    "Correctness theorems prove fuel-independence of semantic results",
    "Fuel integrates naturally with monadic state management",
    "Custom induction principles are crucial for reasoning about fueled recursion"
  ],
  
  "recommendations_for_proofchecker": {
    "immediate": [
      "Add SearchFuel ADT to Logos.Core.Automation.ProofSearch",
      "Define defaultSearchFuel and hugeFuel constants",
      "Refactor main search to accept fuel parameter"
    ],
    
    "short_term": [
      "Add fuel to modal and temporal proof strategies",
      "Implement monadic fuel checking in ProofSearchM",
      "Add fuel consumption metrics and logging"
    ],
    
    "medium_term": [
      "Prove fuel-independence theorems for search correctness",
      "Benchmark optimal fuel values for different proof types",
      "Document fuel requirements in tactic documentation"
    ],
    
    "long_term": [
      "Implement adaptive fuel based on proof complexity",
      "Integrate fuel with caching and memoization",
      "Connect fuel management to RL-based proof search"
    ]
  },
  
  "summary": "The Loogle search for 'fuel' reveals a comprehensive fuel-based recursion infrastructure in Lean 4. The most significant finding is the Lean.Elab.Tactic.Do.Fuel ADT, which provides a robust pattern for bounded computation with both limited and unlimited variants. Fuel is extensively used in: (1) Grind tactic automation for ring solving and AC matching, (2) verification condition generation, (3) property-based testing, and (4) contradiction search. Key design patterns include: ADT-based fuel types, huge fuel constants for practical infinity, fallback to well-founded recursion, and correctness theorems proving fuel-independence. The pattern is highly applicable to ProofChecker's proof search automation, particularly for bounding modal and temporal proof exploration while maintaining soundness guarantees."
}
