{
  "search_query": "iterate",
  "matches_count": 1027,
  "shown_count": 200,
  "report_path": ".opencode/specs/NNN_project/specialist-reports/loogle-iterate.md",
  "search_date": "2025-12-20",
  "top_matches": [
    {
      "name": "Nat.iterate",
      "type": "{α : Sort u} (op : α → α) : ℕ → α → α",
      "library": "Mathlib",
      "module": "Mathlib.Logic.Function.Iterate",
      "notation": "f^[n]",
      "bounding": "Natural number parameter (structurally decreasing)",
      "termination": "Nat-indexed recursion (always terminates)",
      "description": "Iterates a function exactly n times. The fundamental iteration primitive in Lean."
    },
    {
      "name": "Fin.hIterate",
      "type": "(P : ℕ → Sort u_1) {n : ℕ} (init : P 0) (f : (i : Fin n) → P ↑i → P (↑i + 1)) : P n",
      "library": "Lean Init",
      "module": "Init.Data.Fin.Iterate",
      "notation": null,
      "bounding": "Fin-bounded (0 to n-1), structurally decreasing",
      "termination": "Well-founded recursion on Fin n (always terminates)",
      "description": "Heterogeneous iteration with dependent types. Type can change at each step based on index."
    },
    {
      "name": "IO.iterate",
      "type": "{α β : Type} (a : α) (f : α → IO (α ⊕ β)) : IO β",
      "library": "Lean Init",
      "module": "Init.System.IO",
      "notation": null,
      "bounding": "Unbounded - relies on function returning Sum.inr eventually",
      "termination": "Explicit exit condition via Sum type (no static guarantee)",
      "description": "Iterates an IO action until completion. Sum.inl continues with new state, Sum.inr terminates."
    },
    {
      "name": "MLList.iterate",
      "type": "{m : Type u_1 → Type u_1} {α : Type u_1} [Monad m] (f : m α) : MLList m α",
      "library": "Batteries (Std)",
      "module": "Batteries.Data.MLList.Basic",
      "notation": null,
      "bounding": "Unbounded - creates infinite lazy list",
      "termination": "Lazy evaluation - consumption controls termination",
      "description": "Constructs a monadic lazy list by repeatedly running a monadic action."
    },
    {
      "name": "Nondet.iterate",
      "type": "{σ : Type} {m : Type → Type} [Monad m] [Lean.MonadBacktrack σ m] {α : Type} (f : α → Nondet m α) (a : α) : Nondet m α",
      "library": "Batteries (Std)",
      "module": "Batteries.Control.Nondet.Basic",
      "notation": null,
      "bounding": "Unbounded - explores entire search space",
      "termination": "Backtracking monad controls search termination",
      "description": "All iterations of a non-deterministic function (depth-first search)."
    },
    {
      "name": "List.iterate",
      "type": "{α : Type u_1} (f : α → α) (a : α) (n : ℕ) : List α",
      "library": "Mathlib",
      "module": "Mathlib.Data.List.Defs",
      "notation": null,
      "bounding": "Natural number parameter",
      "termination": "Nat-indexed recursion (always terminates)",
      "description": "Returns list of first n iterations: [a, f a, f (f a), ..., f^[n-1] a]"
    },
    {
      "name": "iterate (tactic)",
      "type": "Lean.ParserDescr (tactic syntax)",
      "library": "Lean Init",
      "module": "Init.TacticsExtra",
      "notation": "iterate n tac | iterate tac",
      "bounding": "With n: Nat-bounded | Without n: Until failure",
      "termination": "Counted: Nat-bounded | Uncounted: First tactic failure",
      "description": "Tactic combinator. iterate n tac runs tac exactly n times; iterate tac runs until failure."
    },
    {
      "name": "Lean.Order.iterates",
      "type": "{α : Sort u} [Lean.Order.CCPO α] (f : α → α) : α → Prop",
      "library": "Lean Init",
      "module": "Init.Internal.Order.Basic",
      "notation": null,
      "bounding": "Transfinite - based on CCPO structure",
      "termination": "Order-theoretic limits",
      "description": "Transfinite iteration for constructing partial fixpoints in CCPOs."
    }
  ],
  "categories": {
    "core_iteration_functions": 8,
    "tactic_related": 7,
    "property_preserving_theorems": 60,
    "topology_analysis": 25,
    "algebra": 30,
    "data_structures": 15,
    "tree_map_operations": 12,
    "order_theory": 8,
    "measure_theory": 4,
    "dynamics": 3
  },
  "iteration_patterns": [
    {
      "pattern": "Bounded Natural Iteration",
      "examples": ["Nat.iterate", "Fin.hIterate", "List.iterate"],
      "bounding": "Natural number or Fin index",
      "termination": "Structural recursion on Nat (always terminates)",
      "use_when": "You know the exact number of iterations needed"
    },
    {
      "pattern": "Monadic Until-Success Iteration",
      "examples": ["IO.iterate", "MLList.iterate"],
      "bounding": "Explicit exit condition (Sum type or stream consumption)",
      "termination": "No static guarantee; relies on function behavior",
      "use_when": "Iteration count depends on runtime state"
    },
    {
      "pattern": "Search-Based Iteration",
      "examples": ["Nondet.iterate"],
      "bounding": "Search space exploration",
      "termination": "Backtracking monad controls termination",
      "use_when": "Exploring non-deterministic computations"
    },
    {
      "pattern": "Tactic Iteration",
      "examples": ["iterate tactic"],
      "bounding": "Count or until-failure",
      "termination": "Tactic failure or count exhaustion",
      "use_when": "Repeatedly applying proof tactics"
    },
    {
      "pattern": "Transfinite Iteration",
      "examples": ["Lean.Order.iterates"],
      "bounding": "CCPO structure",
      "termination": "Order-theoretic limits",
      "use_when": "Constructing fixpoints in domain theory"
    }
  ],
  "termination_strategies": [
    {
      "strategy": "Nat-indexed",
      "guarantee": "Always terminates",
      "examples": ["Nat.iterate", "Fin.hIterate"],
      "pros": "Simple, total, efficient",
      "cons": "Need to know count upfront"
    },
    {
      "strategy": "Structural recursion",
      "guarantee": "Always terminates",
      "examples": ["All Nat/Fin based"],
      "pros": "Lean accepts automatically",
      "cons": "Limited to decreasing structures"
    },
    {
      "strategy": "Well-founded recursion",
      "guarantee": "Always terminates",
      "examples": ["Fin.hIterate on Fin"],
      "pros": "Flexible, provably total",
      "cons": "Need termination proof"
    },
    {
      "strategy": "Explicit exit (Sum)",
      "guarantee": "No guarantee",
      "examples": ["IO.iterate"],
      "pros": "Natural for state machines",
      "cons": "Must prove termination separately"
    },
    {
      "strategy": "Until-failure",
      "guarantee": "No guarantee",
      "examples": ["iterate tactic"],
      "pros": "Convenient for tactics",
      "cons": "Can loop infinitely"
    },
    {
      "strategy": "Lazy evaluation",
      "guarantee": "No guarantee",
      "examples": ["MLList.iterate", "Stream'.iterate"],
      "pros": "Memory efficient",
      "cons": "Termination on consumption"
    },
    {
      "strategy": "Backtracking monad",
      "guarantee": "No guarantee",
      "examples": ["Nondet.iterate"],
      "pros": "Explores full space",
      "cons": "Can be exponential"
    },
    {
      "strategy": "Order-theoretic",
      "guarantee": "By CCPO structure",
      "examples": ["Lean.Order.iterates"],
      "pros": "Handles infinite cases",
      "cons": "Complex, specialized"
    }
  ],
  "key_theorems": {
    "identity": ["Function.iterate_zero", "Function.iterate_one", "Function.iterate_id"],
    "composition": ["Function.iterate_succ", "Function.iterate_add", "Function.iterate_mul"],
    "commutativity": ["Function.iterate_comm", "Function.Commute.iterate_iterate"],
    "property_preservation": [
      "Function.Injective.iterate",
      "Function.Surjective.iterate",
      "Function.Bijective.iterate",
      "Monotone.iterate",
      "StrictMono.iterate",
      "Continuous.iterate",
      "Differentiable.iterate"
    ],
    "cancellation": ["Function.iterate_cancel", "Function.iterate_add_eq_iterate"]
  },
  "recommendations_for_logos": [
    "Use Nat.iterate (f^[n]) for proof automation when applying transformations a known number of times",
    "Use iterate tactic for proof scripts: 'iterate n tac' for exact repetition",
    "Property preservation is automatic - leverage existing theorems for monotonicity, injectivity, etc.",
    "For dependent types (indexed formulas), consider Fin.hIterate with strong induction principles",
    "Avoid unbounded iterations (IO.iterate, MLList.iterate) unless you have external termination proof",
    "Leverage the extensive theorem library (1027+ theorems) - search pattern: <property>.iterate"
  ],
  "summary": "Loogle search found 1027 declarations containing 'iterate'. The core iteration primitive is Nat.iterate (notation: f^[n]) which applies a function n times using structurally decreasing Nat recursion. Key patterns include: (1) Nat-bounded iteration for total functions, (2) monadic iteration for stateful/IO computations, (3) search-based iteration for non-determinism, (4) tactic iteration for proof automation, and (5) transfinite iteration for fixpoint constructions. The library provides 60+ property-preserving theorems showing that iteration preserves injectivity, surjectivity, monotonicity, continuity, differentiability, and algebraic structure. For the Logos project, Nat.iterate and the iterate tactic are recommended for bounded proof automation with extensive theorem support."
}
