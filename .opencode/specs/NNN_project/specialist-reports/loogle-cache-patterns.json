{
  "report_path": ".opencode/specs/NNN_project/specialist-reports/loogle-cache-patterns.md",
  "query_results": {
    "hashmap_lookup": 3,
    "cache_fallback": 8,
    "stateM": 39,
    "stateT": 102,
    "cache_name": 569,
    "memo_name": 119,
    "memoize_name": 6,
    "lookup_name": 137,
    "insert_name": 5606,
    "hashmap_name": 6786,
    "rbmap_name": 199
  },
  "total_matches": 13434,
  "top_matches": [
    {
      "name": "Std.HashMap.get?",
      "type": "{α : Type u} {β : Type v} {BEq α} {Hashable α} (m : Std.HashMap α β) (a : α) : Option β",
      "library": "Std",
      "module": "Std.Data.HashMap.Basic",
      "relevance": "PRIMARY CACHE LOOKUP PATTERN - Standard way to check if value exists in cache. Notation: m[a]? is preferred. Average O(1) complexity."
    },
    {
      "name": "Std.HashMap.getD",
      "type": "{α : Type u} {β : Type v} {BEq α} {Hashable α} (m : Std.HashMap α β) (a : α) (fallback : β) : β",
      "library": "Std",
      "module": "Std.Data.HashMap.Basic",
      "relevance": "PRIMARY CACHE-WITH-FALLBACK PATTERN - Essential for proof search with computation fallback. Returns fallback if key not present. Average O(1) complexity."
    },
    {
      "name": "Std.HashMap.insert",
      "type": "{α : Type u} {β : Type v} {BEq α} {Hashable α} (m : Std.HashMap α β) (a : α) (b : β) : Std.HashMap α β",
      "library": "Std",
      "module": "Std.Data.HashMap.Basic",
      "relevance": "PRIMARY CACHE INSERT OPERATION - Inserts or replaces mapping. Both key and value replaced if key exists. Average O(1) complexity."
    },
    {
      "name": "StateT",
      "type": "(σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)",
      "library": "Lean Core",
      "module": "Init.Control.State",
      "relevance": "COMPOSABLE STATEFUL COMPUTATION - Monad transformer for adding mutable state to any monad. Essential for proof search with cache state management. Combines with MetaM, IO, etc."
    },
    {
      "name": "Std.Sat.AIG.Cache",
      "type": "(α : Type) [DecidableEq α] [Hashable α] (decls : Array (Std.Sat.AIG.Decl α)) : Type",
      "library": "Std",
      "module": "Std.Sat.AIG.Basic",
      "relevance": "CACHE WITH CORRECTNESS PROOFS - Verified cache for SAT solving. Cache hits include proofs of correctness. Excellent model for verified caching in proof systems."
    },
    {
      "name": "Lean.PersistentHashMap.findD",
      "type": "{α : Type u_1} {β : Type u_2} {BEq α} {Hashable α} (m : Lean.PersistentHashMap α β) (a : α) (b₀ : β) : β",
      "library": "Lean Core",
      "module": "Lean.Data.PersistentHashMap",
      "relevance": "PERSISTENT CACHE PATTERN - Immutable hash map with structural sharing. Useful for backtracking search and concurrent access. No linear usage requirement."
    },
    {
      "name": "Batteries.RBMap.find?",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (k : α) : Option β",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "relevance": "ORDERED CACHE LOOKUP - O(log n) lookup in self-balancing tree. Use when ordering matters or range queries needed. Supports lowerBound?, min?, max? operations."
    },
    {
      "name": "memoFix",
      "type": "{α β : Type} [Nonempty β] (f : (α → β) → α → β) : α → β",
      "library": "Mathlib",
      "module": "Mathlib.Util.MemoFix",
      "relevance": "ONLY GENERAL-PURPOSE MEMOIZATION FUNCTION - Takes fixpoint with automatic caching using pointer hash. Useful for tree traversal with shared subtrees."
    },
    {
      "name": "Std.HashMap.containsThenInsertIfNew",
      "type": "{α : Type u} {β : Type v} {BEq α} {Hashable α} (m : Std.HashMap α β) (a : α) (b : β) : Bool × Std.HashMap α β",
      "library": "Std",
      "module": "Std.Data.HashMap.Basic",
      "relevance": "EFFICIENT CACHE-MISS HANDLING - Atomic check-and-insert operation. Returns true if key existed (map unchanged), false if inserted. Faster than separate contains + insertIfNew."
    },
    {
      "name": "Lean.Meta.Simp.Config.memoize",
      "type": "(self : Lean.Meta.Simp.Config) : Bool",
      "library": "Lean Core",
      "module": "Init.MetaTypes",
      "relevance": "SIMPLIFIER CACHING CONTROL - When true (default), simplifier caches results of simplifying each sub-expression. Shows how LEAN's built-in tactics use memoization."
    }
  ],
  "caching_patterns": [
    "HashMap-based caching: Most common pattern, average O(1) operations, well-documented and mature",
    "StateM/StateT state management: Standard for stateful computations, composable with other monads",
    "Verified caching (AIG): Cache hits include correctness proofs, suitable for certified systems",
    "Ordered caching (RBMap): O(log n) operations, maintains sorted order, supports range queries",
    "Persistent caching: Immutable data structures with structural sharing, safe for backtracking",
    "Cache-with-fallback (getD): Returns default value on cache miss, lazy evaluation of default",
    "Memoization (memoFix): Automatic caching for recursive functions using pointer hashing",
    "Multi-level caching: Recent cache + persistent cache for performance optimization",
    "Association lists: Simple O(n) lookup for small caches, no dependencies",
    "Atomic operations: containsThenInsert, getThenInsertIfNew for efficient cache management"
  ],
  "library_distribution": {
    "lean_core": {
      "state_monads": ["StateM", "StateT", "EStateM"],
      "basic_collections": ["List.lookup", "Option.getD", "Array.getD"],
      "lean_specific": ["Lean.PersistentHashMap", "Lean.KVMap", "Lean.NameMap", "Lean.Core.Cache", "Lean.Meta.Cache", "Lean.HasConstCache"]
    },
    "std": {
      "primary_hashmap": "Std.HashMap (1,192 declarations)",
      "tree_maps": ["Std.TreeMap", "Std.TreeSet"],
      "aig_cache": "Std.Sat.AIG.Cache (verified cache for SAT solving)",
      "bv_decision": "Std.Tactic.BVDecide.BVExpr.Cache",
      "iterators": "Std.Iterators.Zip.memoizedLeft"
    },
    "batteries": {
      "rbmap": "Batteries.RBMap (158 declarations)",
      "hashmap": "Batteries.HashMap (31 declarations, wraps Std.HashMap)",
      "heaps": ["Batteries.BinaryHeap", "Batteries.BinomialHeap", "Batteries.PairingHeap"]
    },
    "mathlib": {
      "memoization": "memoFix (general-purpose memoization)",
      "association_lists": ["List.dlookup", "List.lookupAll", "AList", "Finmap"],
      "tactic_caches": ["Mathlib.Tactic.Ring.Cache", "Mathlib.Tactic.ITauto"]
    }
  },
  "recommendations": {
    "tier1_primary": [
      {
        "name": "Std.HashMap",
        "why": "Mature, well-documented, efficient, proven in production",
        "operations": ["get?", "getD", "insert", "insertIfNew", "containsThenInsertIfNew"],
        "complexity": "Average O(1) for all operations",
        "use_for": "General-purpose proof caching, tactic results, expression normalization"
      },
      {
        "name": "StateT + HashMap",
        "why": "Clean composition with MetaM, explicit state management",
        "pattern": "StateT ProofCache MetaM",
        "use_for": "Proof search algorithms, tactic development, multi-phase processing"
      },
      {
        "name": "Lean.PersistentHashMap",
        "why": "Immutable, structural sharing, safe for backtracking",
        "operations": ["find?", "findD", "insert"],
        "use_for": "Backtracking search, concurrent access, incremental compilation"
      }
    ],
    "tier2_specialized": [
      {
        "name": "Batteries.RBMap",
        "why": "Ordered iteration, range queries, no hash function needed",
        "operations": ["find?", "insert", "lowerBound?", "min?", "max?"],
        "complexity": "O(log n) for all operations",
        "use_for": "Proof libraries with ordering, range-based queries"
      },
      {
        "name": "Std.Sat.AIG.Cache",
        "why": "Proven correctness, cache hits include proofs",
        "operations": ["get?", "insert with invariant maintenance"],
        "use_for": "Verified proof checkers, certified systems"
      },
      {
        "name": "memoFix",
        "why": "Automatic memoization of recursive functions",
        "use_for": "Tree traversals with shared subtrees, recursive proof search"
      }
    ],
    "tier3_utility": [
      {
        "name": "List.lookup",
        "why": "Simple, no dependencies, good for small caches",
        "complexity": "O(n)",
        "use_for": "Small proof caches, configuration lookup"
      },
      {
        "name": "Array.groupByKey",
        "why": "Efficient grouping by key",
        "use_for": "Organizing proof batches, grouping tactics"
      }
    ]
  },
  "implementation_strategy": {
    "phase1_basic_caching": {
      "description": "HashMap-based cache with StateT monad",
      "components": ["ProofCache structure", "ProofSearchM monad", "searchWithCache function"],
      "complexity": "O(1) average lookup and insert"
    },
    "phase2_statistics": {
      "description": "Add cache hit/miss tracking",
      "components": ["SearchStats structure", "Hit/miss counters", "Total search counter"],
      "benefit": "Performance monitoring and tuning"
    },
    "phase3_multilevel": {
      "description": "Recent + persistent caching",
      "components": ["Recent HashMap", "Persistent HashMap", "Promotion logic"],
      "benefit": "Optimized for hot paths with full history"
    }
  },
  "performance_considerations": {
    "hashmap": {
      "average_case": "O(1) for lookup, insert, erase",
      "worst_case": "O(n) if hash function is poor",
      "load_factor": "Resizes at 75% capacity",
      "memory": "Overhead from buckets array + linked lists"
    },
    "rbmap": {
      "all_operations": "O(log n)",
      "predictable": "No hash function variance",
      "memory": "Tree node overhead",
      "ordering": "Maintains sorted order"
    },
    "state_monads": {
      "stateM_overhead": "Minimal",
      "stateT_overhead": "Moderate, increases with transformer stack depth",
      "optimization": "Use @[inline] for hot paths"
    },
    "caching_strategy": {
      "presize": "Use emptyWithCapacity to avoid resizing",
      "eviction": "Implement LRU if memory constrained",
      "batch": "Use insertMany for bulk updates",
      "statistics": "Track hit rate to tune cache size"
    }
  },
  "summary": "LEAN 4 provides extensive infrastructure for caching and state management through Std.HashMap (6,786 declarations), StateM/StateT monads (141 declarations), and specialized systems like AIG cache. While explicit memoization support is limited (only memoFix and simplifier config), the combination of HashMap for storage and StateT for state management provides a solid foundation for efficient proof search caching. Recommended approach: Start with Std.HashMap + StateT, add statistics tracking, consider Lean.PersistentHashMap for backtracking, and study AIG cache for verified caching patterns."
}
