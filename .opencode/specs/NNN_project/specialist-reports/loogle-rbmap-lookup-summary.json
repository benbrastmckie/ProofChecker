{
  "type_pattern": "RBMap α β → α → Option β",
  "search_date": "2025-12-21",
  "queries_executed": 6,
  "matches_count": 25,
  "report_path": ".opencode/specs/NNN_project/specialist-reports/loogle-rbmap-lookup.md",
  "exact_matches": [
    {
      "name": "Batteries.RBMap.find?",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (k : α) : Option β",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "description": "Find the value corresponding to key k. Primary lookup function with O(log n) complexity.",
      "complexity": "O(log n)",
      "recommended": true
    },
    {
      "name": "Lean.RBMap.find?",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} : Lean.RBMap α β cmp → α → Option β",
      "library": "Lean",
      "module": "Lean.Data.RBMap",
      "description": "Core implementation of RBMap lookup. Minimal documentation.",
      "complexity": "Not specified",
      "recommended": false
    }
  ],
  "partial_matches": [
    {
      "name": "Batteries.RBMap.findEntry?",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (k : α) : Option (α × β)",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "description": "Find an entry in the tree with key equal to k. Returns both key and value.",
      "similarity": "Returns Option (α × β) instead of Option β"
    },
    {
      "name": "Lean.RBMap.findCore?",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} : Lean.RBMap α β cmp → α → Option ((_ : α) × β)",
      "library": "Lean",
      "module": "Lean.Data.RBMap",
      "description": "Core implementation of entry lookup.",
      "similarity": "Returns Option (α × β) instead of Option β"
    },
    {
      "name": "Batteries.RBMap.findD",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (k : α) (v₀ : β) : β",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "description": "Find the value corresponding to key k, or return v₀ if not found.",
      "similarity": "Returns β with default instead of Option β"
    },
    {
      "name": "Lean.RBMap.findD",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Lean.RBMap α β cmp) (k : α) (v₀ : β) : β",
      "library": "Lean",
      "module": "Lean.Data.RBMap",
      "description": "Core implementation of lookup with default.",
      "similarity": "Returns β with default instead of Option β"
    },
    {
      "name": "Batteries.RBMap.find!",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} [Inhabited β] (t : Batteries.RBMap α β cmp) (k : α) : β",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "description": "Attempts to find the value with key k and panics if not found.",
      "similarity": "Returns β (panics on failure) instead of Option β"
    },
    {
      "name": "Lean.RBMap.find!",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} [Inhabited β] (t : Lean.RBMap α β cmp) (k : α) : β",
      "library": "Lean",
      "module": "Lean.Data.RBMap",
      "description": "Core implementation of lookup with panic.",
      "similarity": "Returns β (panics on failure) instead of Option β"
    },
    {
      "name": "Batteries.RBMap.contains",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (a : α) : Bool",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Basic",
      "description": "Returns true if the given key a is in the RBMap.",
      "similarity": "Returns Bool instead of Option β"
    },
    {
      "name": "Lean.RBMap.contains",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Lean.RBMap α β cmp) (a : α) : Bool",
      "library": "Lean",
      "module": "Lean.Data.RBMap",
      "description": "Core implementation of membership test.",
      "similarity": "Returns Bool instead of Option β"
    }
  ],
  "related_theorems": [
    {
      "name": "Batteries.RBMap.find?_congr",
      "type": "{α : Type u_1} {cmp : α → α → Ordering} {β : Type u_2} {k₁ k₂ : α} [Std.TransCmp cmp] (t : Batteries.RBMap α β cmp) (h : cmp k₁ k₂ = Ordering.eq) : t.find? k₁ = t.find? k₂",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Congruence theorem: equivalent keys return same result"
    },
    {
      "name": "Batteries.RBMap.find?.eq_1",
      "type": "{α : Type u} {β : Type v} {cmp : α → α → Ordering} (t : Batteries.RBMap α β cmp) (k : α) : t.find? k = Option.map (fun x => x.2) (t.findEntry? k)",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Relates find? to findEntry?"
    },
    {
      "name": "Batteries.RBMap.find?_some",
      "type": "{α : Type u_1} {cmp : α → α → Ordering} {β : Type u_2} {x : α} {v : β} [Std.TransCmp cmp] {t : Batteries.RBMap α β cmp} : t.find? x = some v ↔ ∃ y, (y, v) ∈ t.toList ∧ cmp x y = Ordering.eq",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Characterizes when find? returns some v"
    },
    {
      "name": "Batteries.RBMap.contains_iff_find?",
      "type": "{α : Type u_1} {β : Type u_2} {cmp : α → α → Ordering} {x : α} {t : Batteries.RBMap α β cmp} : t.contains x = true ↔ ∃ v, t.find? x = some v",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Relates contains to find?"
    },
    {
      "name": "Batteries.RBMap.find?_insert",
      "type": "{α : Type u_1} {cmp : α → α → Ordering} {β : Type u_2} [Std.TransCmp cmp] (t : Batteries.RBMap α β cmp) (k : α) (v : β) (k' : α) : (t.insert k v).find? k' = if cmp k' k = Ordering.eq then some v else t.find? k'",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Describes lookup behavior after insertion"
    },
    {
      "name": "Batteries.RBMap.find?_insert_of_eq",
      "type": "{α : Type u_1} {cmp : α → α → Ordering} {β : Type u_2} {k' k : α} {v : β} [Std.TransCmp cmp] (t : Batteries.RBMap α β cmp) (h : cmp k' k = Ordering.eq) : (t.insert k v).find? k' = some v",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Looking up inserted key returns inserted value"
    },
    {
      "name": "Batteries.RBMap.find?_insert_of_ne",
      "type": "{α : Type u_1} {cmp : α → α → Ordering} {β : Type u_2} {k' k : α} {v : β} [Std.TransCmp cmp] (t : Batteries.RBMap α β cmp) (h : cmp k' k ≠ Ordering.eq) : (t.insert k v).find? k' = t.find? k'",
      "library": "Batteries",
      "module": "Batteries.Data.RBMap.Lemmas",
      "description": "Looking up different key unaffected by insertion"
    }
  ],
  "search_queries": [
    {
      "query": "RBMap α β → α → Option β",
      "status": "error",
      "message": "Requires namespace qualification (Batteries.RBMap or Lean.RBMap)"
    },
    {
      "query": "RBMap _ _ → _ → Option _",
      "status": "error",
      "message": "Requires namespace qualification"
    },
    {
      "query": "RBMap.find",
      "status": "success",
      "results": 23,
      "batteries_count": 19,
      "lean_count": 4
    },
    {
      "query": "RBMap.lookup",
      "status": "success",
      "results": 0,
      "message": "No lookup function exists in LEAN 4"
    },
    {
      "query": "RBMap.get",
      "status": "success",
      "results": 0,
      "message": "No get function exists in LEAN 4"
    },
    {
      "query": "RBMap _ _ → _ → _",
      "status": "error",
      "message": "Type error - RBMap requires comparison function parameter"
    }
  ],
  "library_statistics": {
    "batteries": {
      "total_declarations": 113,
      "lookup_functions": 8,
      "theorems": 50,
      "modules": ["Basic", "Lemmas", "Alter", "WF"]
    },
    "lean": {
      "total_declarations": 38,
      "lookup_functions": 4,
      "theorems": 0,
      "modules": ["Lean.Data.RBMap"]
    }
  },
  "recommendations": {
    "primary_function": "Batteries.RBMap.find?",
    "import_statement": "import Batteries.Data.RBMap.Basic",
    "verification_import": "import Batteries.Data.RBMap.Lemmas",
    "prefer_batteries": true,
    "reason": "Extensive documentation, theorem support, and verified complexity guarantees"
  },
  "naming_convention_note": "LEAN 4 uses ? suffix for functions returning Option: find? (returns Option β), find! (panics), findD (uses default). No lookup or get functions exist.",
  "summary": "Successfully identified Batteries.RBMap.find? and Lean.RBMap.find? as exact matches for type signature RBMap α β → α → Option β. Batteries implementation strongly recommended for production use. Key finding: LEAN 4 uses find? naming convention instead of lookup or get."
}
