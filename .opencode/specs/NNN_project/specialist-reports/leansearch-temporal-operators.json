{
  "metadata": {
    "date": "2025-12-21",
    "specialist": "LeanSearch Specialist",
    "search_method": "Loogle API (Type-based search)",
    "lean_version": "LEAN 4 (latest)",
    "mathlib_version": "Latest (2025-12)",
    "report_path": ".opencode/specs/NNN_project/specialist-reports/leansearch-temporal-operators.md"
  },
  "search_queries": [
    {
      "query": "always",
      "results_found": 60,
      "relevance": "low",
      "key_findings": ["IsAlwaysFinite", "isAlwaysZero", "MonadAlwaysExcept"]
    },
    {
      "query": "eventually",
      "results_found": 1210,
      "results_shown": 200,
      "relevance": "very_high",
      "key_findings": ["Filter.Eventually", "Filter.EventuallyEq", "Filter.EventuallyLE", "Filter.eventually_atTop"]
    },
    {
      "query": "until",
      "results_found": 89,
      "relevance": "medium",
      "key_findings": ["SimpleGraph.Walk.takeUntil", "SimpleGraph.Walk.dropUntil", "Homotopy.mkInductive", "Homotopy.mkCoinductive"]
    },
    {
      "query": "fixpoint",
      "results_found": 68,
      "relevance": "very_high",
      "key_findings": ["Lean.Parser.Termination.inductiveFixpoint", "Lean.Parser.Termination.coinductiveFixpoint", "OrderHom.gfp", "OrderHom.lfp"]
    },
    {
      "query": "temporal",
      "results_found": 0,
      "relevance": "none",
      "key_findings": []
    }
  ],
  "statistics": {
    "total_queries": 5,
    "total_results_found": 1427,
    "total_results_shown": 417,
    "highly_relevant": 25,
    "medium_relevant": 50,
    "low_relevant": 342
  },
  "top_results": [
    {
      "rank": 1,
      "name": "Filter.Eventually",
      "library": "Mathlib.Order.Filter.Defs",
      "type_signature": "{α : Type u_1} (p : α → Prop) (f : Filter α) : Prop",
      "description": "f.Eventually p or ∀ᶠ x in f, p x means {x | p x} ∈ f",
      "category": "definition",
      "relevance_score": 0.95,
      "source_query": "eventually",
      "usage": "Direct implementation of 'eventually' temporal operator",
      "notation": "∀ᶠ x in f, p x"
    },
    {
      "rank": 2,
      "name": "Lean.Parser.Termination.inductiveFixpoint",
      "library": "Lean.Parser.Term",
      "type_signature": "Lean.Parser.Parser",
      "description": "Defines inductive predicates as least fixed points using Knaster-Tarski theorem",
      "category": "definition",
      "relevance_score": 0.95,
      "source_query": "fixpoint",
      "usage": "Define temporal operators as least fixpoints (e.g., 'always' = lfp)",
      "is_new_feature": true
    },
    {
      "rank": 3,
      "name": "Lean.Parser.Termination.coinductiveFixpoint",
      "library": "Lean.Parser.Term",
      "type_signature": "Lean.Parser.Parser",
      "description": "Defines coinductive predicates as greatest fixed points using Knaster-Tarski theorem",
      "category": "definition",
      "relevance_score": 0.95,
      "source_query": "fixpoint",
      "usage": "Define temporal operators as greatest fixpoints (e.g., 'eventually' = gfp)",
      "is_new_feature": true
    },
    {
      "rank": 4,
      "name": "Filter.EventuallyEq",
      "library": "Mathlib.Order.Filter.Defs",
      "type_signature": "{α β : Type} (l : Filter α) (f g : α → β) : Prop",
      "description": "Two functions are eventually equal along a filter",
      "category": "definition",
      "relevance_score": 0.90,
      "source_query": "eventually",
      "usage": "Temporal equality - functions equal 'eventually'"
    },
    {
      "rank": 5,
      "name": "Filter.EventuallyLE",
      "library": "Mathlib.Order.Filter.Defs",
      "type_signature": "{α β : Type} [LE β] (l : Filter α) (f g : α → β) : Prop",
      "description": "Function eventually less than or equal to another",
      "category": "definition",
      "relevance_score": 0.90,
      "source_query": "eventually",
      "usage": "Temporal ordering relations"
    },
    {
      "rank": 6,
      "name": "OrderHom.gfp",
      "library": "Mathlib.Order.FixedPoints",
      "type_signature": "{α : Type u} [CompleteLattice α] (f : α →o α) : α",
      "description": "Greatest fixed point of an order homomorphism",
      "category": "definition",
      "relevance_score": 0.88,
      "source_query": "fixpoint",
      "usage": "Compute greatest fixpoints for coinductive temporal operators"
    },
    {
      "rank": 7,
      "name": "OrderHom.isGreatest_gfp",
      "library": "Mathlib.Order.FixedPoints",
      "type_signature": "{α : Type u} [CompleteLattice α] (f : α →o α) : IsGreatest (Function.fixedPoints ↑f) (OrderHom.gfp f)",
      "description": "Proof that gfp is the greatest fixed point",
      "category": "theorem",
      "relevance_score": 0.85,
      "source_query": "greatest",
      "usage": "Verify correctness of coinductive temporal definitions"
    },
    {
      "rank": 8,
      "name": "Homotopy.mkInductive",
      "library": "Mathlib.Algebra.Homology.Homotopy",
      "type_signature": "Complex inductive construction for chain complexes",
      "description": "Constructor for homotopy working by induction",
      "category": "definition",
      "relevance_score": 0.75,
      "source_query": "until",
      "usage": "Pattern for inductive temporal structure construction"
    },
    {
      "rank": 9,
      "name": "Homotopy.mkCoinductive",
      "library": "Mathlib.Algebra.Homology.Homotopy",
      "type_signature": "Complex coinductive construction for cochain complexes",
      "description": "Constructor for homotopy working by coinduction",
      "category": "definition",
      "relevance_score": 0.75,
      "source_query": "until",
      "usage": "Pattern for coinductive temporal structure construction"
    },
    {
      "rank": 10,
      "name": "List.filter",
      "library": "Init.Data.List.Basic",
      "type_signature": "{α : Type u} (p : α → Bool) (l : List α) : List α",
      "description": "Returns elements satisfying predicate",
      "category": "definition",
      "relevance_score": 0.70,
      "source_query": "until",
      "usage": "Filter temporal traces/paths by properties"
    },
    {
      "rank": 11,
      "name": "SimpleGraph.Walk.takeUntil",
      "library": "Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkDecomp",
      "type_signature": "{V : Type u} {G : SimpleGraph V} [DecidableEq V] {v w : V} (p : G.Walk v w) (u : V) : u ∈ p.support → G.Walk v u",
      "description": "Path up until (and including) a vertex",
      "category": "definition",
      "relevance_score": 0.70,
      "source_query": "until",
      "usage": "'Until' operator on graph paths (temporal traces)"
    },
    {
      "rank": 12,
      "name": "SimpleGraph.Walk.dropUntil",
      "library": "Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkDecomp",
      "type_signature": "{V : Type u} {G : SimpleGraph V} [DecidableEq V] {v w : V} (p : G.Walk v w) (u : V) : u ∈ p.support → G.Walk u w",
      "description": "Path from (and including) a vertex to end",
      "category": "definition",
      "relevance_score": 0.70,
      "source_query": "until",
      "usage": "Complement of 'until' on paths"
    },
    {
      "rank": 13,
      "name": "Filter.eventually_atTop",
      "library": "Mathlib.Order.Filter.AtTopBot.Basic",
      "type_signature": "{α : Type u_3} [Preorder α] [IsDirectedOrder α] {p : α → Prop} [Nonempty α] : (∀ᶠ (x : α) in Filter.atTop, p x) ↔ ∃ a, ∀ b ≥ a, p b",
      "description": "Eventually at top characterization",
      "category": "theorem",
      "relevance_score": 0.68,
      "source_query": "eventually",
      "usage": "Temporal 'eventually' for ordered types"
    },
    {
      "rank": 14,
      "name": "Lean.Parser.Command.inductive",
      "library": "Lean.Parser.Command",
      "type_signature": "Lean.Parser.Parser",
      "description": "Parser for inductive type definitions",
      "category": "definition",
      "relevance_score": 0.65,
      "source_query": "inductive",
      "usage": "Define inductive temporal structures"
    },
    {
      "rank": 15,
      "name": "Lean.Parser.Command.coinductive",
      "library": "Lean.Parser.Command",
      "type_signature": "Lean.Parser.Parser",
      "description": "Parser for coinductive type definitions",
      "category": "definition",
      "relevance_score": 0.65,
      "source_query": "coinductive",
      "usage": "Define coinductive temporal structures (infinite traces)"
    }
  ],
  "key_libraries": {
    "filter_theory": {
      "primary": "Mathlib.Order.Filter.Defs",
      "related": [
        "Mathlib.Order.Filter.Basic",
        "Mathlib.Order.Filter.AtTopBot.Basic"
      ],
      "key_components": [
        "Filter.Eventually",
        "Filter.EventuallyEq",
        "Filter.EventuallyLE",
        "Filter.eventually_atTop"
      ]
    },
    "fixpoint_theory": {
      "primary": "Mathlib.Order.FixedPoints",
      "lean_core": "Lean.Parser.Termination",
      "key_components": [
        "OrderHom.gfp",
        "OrderHom.lfp",
        "inductiveFixpoint",
        "coinductiveFixpoint"
      ]
    },
    "graph_theory": {
      "primary": "Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkDecomp",
      "key_components": [
        "Walk.takeUntil",
        "Walk.dropUntil"
      ]
    },
    "inductive_coinductive": {
      "primary": "Lean.Parser.Command",
      "elaboration": "Lean.Elab.Coinductive",
      "key_components": [
        "inductive",
        "coinductive"
      ]
    }
  },
  "key_insights": [
    {
      "insight": "Filter Theory is Temporal Logic in Disguise",
      "description": "LEAN 4's Filter library provides rich framework for eventual reasoning",
      "mappings": {
        "Filter.Eventually": "temporal eventually (◇)",
        "Filter.Frequently": "temporal infinitely often",
        "Filter.atTop": "in the limit",
        "Filter.EventuallyEq": "temporal equality"
      }
    },
    {
      "insight": "New Fixpoint Features in LEAN 4",
      "description": "inductiveFixpoint and coinductiveFixpoint are NEW features",
      "features": [
        "Automatic monotonicity checking",
        "Lattice-theoretic foundations (Knaster-Tarski)",
        "Clean syntax for fixpoint definitions",
        "Integration with LEAN 4's elaborator"
      ]
    },
    {
      "insight": "Inductive vs Coinductive",
      "inductive": {
        "type": "least fixpoint",
        "use_cases": ["Safety properties", "always operator", "finite traces"]
      },
      "coinductive": {
        "type": "greatest fixpoint",
        "use_cases": ["Liveness properties", "eventually operator", "infinite traces"]
      }
    },
    {
      "insight": "Graph Walks as Temporal Traces",
      "description": "SimpleGraph.Walk provides useful patterns for temporal operators",
      "patterns": [
        "takeUntil/dropUntil for path decomposition",
        "Membership proofs for vertices in paths",
        "Inductive structure for finite paths"
      ]
    },
    {
      "insight": "No Explicit Temporal Logic in Mathlib",
      "description": "Mathlib lacks explicit temporal logic operators but provides all foundations",
      "foundations": [
        "Order theory (complete lattices)",
        "Fixpoint theory",
        "Filter theory (eventual reasoning)",
        "Inductive/coinductive definitions"
      ]
    }
  ],
  "implementation_recommendations": {
    "phase_1": {
      "name": "Use Filter Theory",
      "approach": "Start with Filter.Eventually for basic temporal operators",
      "imports": [
        "Mathlib.Order.Filter.Defs",
        "Mathlib.Order.Filter.AtTopBot.Basic"
      ],
      "example_operators": {
        "eventually": "∃ n, ∀ m ≥ n, P (trace m)",
        "always": "∀ n, P (trace n)"
      }
    },
    "phase_2": {
      "name": "Adopt Fixpoint Definitions",
      "approach": "Use new inductiveFixpoint/coinductiveFixpoint for formal definitions",
      "features": [
        "Automatic monotonicity checking",
        "Clean syntax",
        "Lattice-theoretic foundations"
      ]
    },
    "phase_3": {
      "name": "Leverage OrderHom.gfp/lfp",
      "approach": "For advanced fixpoint reasoning",
      "imports": ["Mathlib.Order.FixedPoints"],
      "use_cases": [
        "Prove fixpoint properties",
        "Establish equivalences",
        "Advanced temporal reasoning"
      ]
    }
  },
  "operator_implementations": {
    "eventually": {
      "symbol": "◇",
      "approaches": [
        {
          "method": "Filter-based",
          "definition": "Filter.Eventually P (Filter.atTop.map trace)"
        },
        {
          "method": "Coinductive fixpoint",
          "definition": "coinductive_fixpoint Eventually (P : State → Prop) (trace : ℕ → State) : Prop := fun E => P (trace 0) ∨ E P (trace ∘ Nat.succ)"
        },
        {
          "method": "Direct existential",
          "definition": "∃ n, ∀ m ≥ n, P (trace m)"
        }
      ]
    },
    "always": {
      "symbol": "□",
      "approaches": [
        {
          "method": "Inductive fixpoint",
          "definition": "inductive_fixpoint Always (P : State → Prop) (trace : ℕ → State) : Prop := fun A => P (trace 0) ∧ A P (trace ∘ Nat.succ)"
        },
        {
          "method": "Universal quantification",
          "definition": "∀ n, P (trace n)"
        }
      ]
    },
    "until": {
      "symbol": "U",
      "approaches": [
        {
          "method": "Inductive definition",
          "definition": "inductive Until (P Q : State → Prop) : (ℕ → State) → Prop | now {trace} : Q (trace 0) → Until P Q trace | later {trace} : P (trace 0) → Until P Q (trace ∘ Nat.succ) → Until P Q trace"
        }
      ],
      "inspiration": "SimpleGraph.Walk.takeUntil"
    },
    "since": {
      "symbol": "S",
      "approaches": [
        {
          "method": "Inductive definition (past-oriented)",
          "definition": "inductive Since (P Q : State → Prop) : (ℤ → State) → ℤ → Prop | now {trace t} : Q (trace t) → Since P Q trace t | earlier {trace t} : P (trace t) → Since P Q trace (t - 1) → Since P Q trace t"
        }
      ]
    }
  },
  "next_steps": [
    "Review this JSON summary and the full markdown report",
    "Prototype temporal operators using Filter theory (Phase 1)",
    "Experiment with inductiveFixpoint/coinductiveFixpoint syntax",
    "Prove equivalences between Filter-based and fixpoint-based definitions",
    "Integrate temporal operators with existing Logos modal logic framework",
    "Study SimpleGraph.Walk patterns for 'until' operator implementation",
    "Consider configuring LeanSearch MCP server for future semantic searches"
  ],
  "summary": "Successfully identified LEAN 4/Mathlib components for temporal operator implementation through 5 Loogle searches. Discovered that Filter theory provides ready-made temporal semantics (Filter.Eventually ≈ ◇) and new LEAN 4 fixpoint features (inductiveFixpoint/coinductiveFixpoint) enable formal temporal operator definitions. No explicit temporal logic exists in Mathlib, but all necessary foundations are present. Recommended 3-phase implementation: (1) Filter theory prototypes, (2) Fixpoint formalizations, (3) Advanced OrderHom reasoning."
}
