{
  "search_metadata": {
    "pattern": "\"compare\"",
    "search_type": "name_substring",
    "date": "2025-12-21",
    "total_matches": 546,
    "matches_shown": 200,
    "report_path": ".opencode/specs/NNN_project/specialist-reports/loogle-compare-functions.md"
  },
  "core_functions": [
    {
      "name": "Ord.compare",
      "type": "{α : Type u} [self : Ord α] : α → α → Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "core",
      "description": "Compare two elements in α using the comparator contained in an [Ord α] instance"
    },
    {
      "name": "compareOn",
      "type": "{β : Type u_1} {α : Sort u_2} [ord : Ord β] (f : α → β) (x y : α) : Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "core",
      "description": "Compares two values by comparing the results of applying a function"
    },
    {
      "name": "compareLex",
      "type": "{α : Sort u_1} {β : Sort u_2} (cmp₁ cmp₂ : α → β → Ordering) (a : α) (b : β) : Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "core",
      "description": "Compares a and b lexicographically by cmp₁ and cmp₂"
    },
    {
      "name": "compareOfLessAndBEq",
      "type": "{α : Type u_1} (x y : α) [LT α] [Decidable (x < y)] [BEq α] : Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "core",
      "description": "Uses a decidable less-than relation and Boolean equality to find an Ordering"
    },
    {
      "name": "compareOfLessAndEq",
      "type": "{α : Type u_1} (x y : α) [LT α] [Decidable (x < y)] [DecidableEq α] : Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "core",
      "description": "Uses decidable less-than and equality relations to find an Ordering"
    },
    {
      "name": "List.compareLex",
      "type": "{α : Type u_1} (cmp : α → α → Ordering) : List α → List α → Ordering",
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "category": "type_specific",
      "description": "Lexicographic comparison for lists"
    },
    {
      "name": "Array.compareLex",
      "type": "{α : Type u_1} (cmp : α → α → Ordering) (a₁ a₂ : Array α) : Ordering",
      "module": "Init.Data.Ord.Array",
      "library": "Init",
      "category": "type_specific",
      "description": "Lexicographic comparison for arrays"
    },
    {
      "name": "Vector.compareLex",
      "type": "{α : Type u_1} {n : ℕ} (cmp : α → α → Ordering) (a b : Vector α n) : Ordering",
      "module": "Init.Data.Ord.Vector",
      "library": "Init",
      "category": "type_specific",
      "description": "Lexicographic comparison for vectors"
    }
  ],
  "type_specific_comparisons": {
    "Nat": {
      "module": "Init.Data.Nat.Compare",
      "library": "Init",
      "key_theorems": [
        "Nat.compare_eq_eq : compare a b = Ordering.eq ↔ a = b",
        "Nat.compare_eq_lt : compare a b = Ordering.lt ↔ a < b",
        "Nat.compare_eq_gt : compare a b = Ordering.gt ↔ b < a",
        "Nat.compare_swap : (compare a b).swap = compare b a",
        "Nat.isLE_compare : (compare a b).isLE = true ↔ a ≤ b",
        "Nat.isGE_compare : (compare a b).isGE = true ↔ b ≤ a"
      ]
    },
    "Int": {
      "module": "Init.Data.Int.Compare",
      "library": "Init",
      "key_theorems": [
        "Int.compare_eq_eq : compare a b = Ordering.eq ↔ a = b",
        "Int.compare_eq_lt : compare a b = Ordering.lt ↔ a < b",
        "Int.compare_eq_gt : compare a b = Ordering.gt ↔ b < a",
        "Int.compare_swap : (compare a b).swap = compare b a",
        "Int.isLE_compare : (compare a b).isLE = true ↔ a ≤ b",
        "Int.isGE_compare : (compare a b).isGE = true ↔ b ≤ a"
      ]
    },
    "List": {
      "module": "Init.Data.Ord.Basic",
      "library": "Init",
      "key_theorems": [
        "List.compareLex_nil_nil : List.compareLex cmp [] [] = Ordering.eq",
        "List.compareLex_cons_cons : List.compareLex cmp (x :: xs) (y :: ys) = (cmp x y).then (List.compareLex cmp xs ys)",
        "List.compare_eq_compareLex : compare = List.compareLex compare"
      ]
    },
    "Array": {
      "module": "Init.Data.Ord.Array",
      "library": "Init",
      "key_theorems": [
        "Array.compare_eq_compareLex : compare = Array.compareLex compare",
        "Array.compareLex_eq_compareLex_toList : Array.compareLex cmp a₁ a₂ = List.compareLex cmp a₁.toList a₂.toList"
      ]
    },
    "Vector": {
      "module": "Init.Data.Ord.Vector",
      "library": "Init",
      "key_theorems": [
        "Vector.compareLex_eq_compareLex_toArray : Vector.compareLex cmp a b = Array.compareLex cmp a.toArray b.toArray",
        "Vector.compareLex_eq_compareLex_toList : Vector.compareLex cmp a b = List.compareLex cmp a.toList b.toList"
      ]
    }
  },
  "lawfulness_properties": {
    "reflexivity": [
      {
        "name": "Std.ReflCmp.compare_self",
        "type": "{α : Type u} {cmp : α → α → Ordering} [self : Std.ReflCmp cmp] {a : α} : cmp a a = Ordering.eq",
        "module": "Init.Data.Order.Ord",
        "description": "Comparison is reflexive"
      },
      {
        "name": "Std.ReflOrd.compare_self",
        "type": "{α : Type u} [Ord α] [Std.ReflOrd α] {a : α} : compare a a = Ordering.eq",
        "module": "Init.Data.Order.Ord"
      }
    ],
    "lawful_equality": [
      {
        "name": "Std.LawfulEqCmp.eq_of_compare",
        "type": "{α : Type u} {cmp : α → α → Ordering} [self : Std.LawfulEqCmp cmp] {a b : α} : cmp a b = Ordering.eq → a = b",
        "module": "Init.Data.Order.Ord",
        "description": "If two values compare equal, then they are logically equal"
      },
      {
        "name": "Std.LawfulEqCmp.compare_eq_iff_eq",
        "type": "{α : Type u} {cmp : α → α → Ordering} [Std.LawfulEqCmp cmp] {a b : α} : cmp a b = Ordering.eq ↔ a = b",
        "module": "Init.Data.Order.Ord"
      },
      {
        "name": "Std.LawfulEqOrd.eq_of_compare",
        "type": "{α : Type u} [Ord α] [Std.LawfulEqOrd α] {a b : α} : compare a b = Ordering.eq → a = b",
        "module": "Init.Data.Order.Ord"
      },
      {
        "name": "Std.LawfulEqOrd.compare_eq_iff_eq",
        "type": "{α : Type u} [Ord α] [Std.LawfulEqOrd α] {a b : α} : compare a b = Ordering.eq ↔ a = b",
        "module": "Init.Data.Order.Ord"
      }
    ],
    "boolean_equality": [
      {
        "name": "Std.LawfulBEqCmp.isEq_compare_eq_beq",
        "type": "{α : Type u} [BEq α] {cmp : α → α → Ordering} [Std.LawfulBEqCmp cmp] {a b : α} : (cmp a b).isEq = (a == b)",
        "module": "Init.Data.Order.Ord"
      },
      {
        "name": "Std.LawfulBEqCmp.compare_eq_iff_beq",
        "type": "{α : Type u} {inst✝ : BEq α} {cmp : α → α → Ordering} [self : Std.LawfulBEqCmp cmp] {a b : α} : cmp a b = Ordering.eq ↔ (a == b) = true",
        "module": "Init.Data.Order.Ord",
        "description": "If two values compare equal, then they are boolean equal"
      }
    ],
    "order_relations": [
      {
        "name": "Std.LawfulOrderOrd.isLE_compare",
        "type": "{α : Type u} {inst✝ : Ord α} {inst✝¹ : LE α} [self : Std.LawfulOrderOrd α] (a b : α) : (compare a b).isLE = true ↔ a ≤ b",
        "module": "Init.Data.Order.ClassesExtra"
      },
      {
        "name": "Std.LawfulOrderOrd.isGE_compare",
        "type": "{α : Type u} {inst✝ : Ord α} {inst✝¹ : LE α} [self : Std.LawfulOrderOrd α] (a b : α) : (compare a b).isGE = true ↔ b ≤ a",
        "module": "Init.Data.Order.ClassesExtra"
      },
      {
        "name": "Std.compare_eq_lt",
        "type": "{α : Type u} [Ord α] [LT α] [LE α] [Std.LawfulOrderOrd α] [Std.LawfulOrderLT α] {a b : α} : compare a b = Ordering.lt ↔ a < b",
        "module": "Init.Data.Order.FactoriesExtra"
      },
      {
        "name": "Std.compare_eq_gt",
        "type": "{α : Type u} [Ord α] [LT α] [LE α] [Std.LawfulOrderOrd α] [Std.LawfulOrderLT α] {a b : α} : compare a b = Ordering.gt ↔ b < a",
        "module": "Init.Data.Order.FactoriesExtra"
      }
    ]
  },
  "library_breakdown": {
    "Init": {
      "modules": [
        "Init.Data.Ord.Basic",
        "Init.Data.Nat.Compare",
        "Init.Data.Int.Compare",
        "Init.Data.Ord.Array",
        "Init.Data.Ord.Vector",
        "Init.Data.Order.Ord",
        "Init.Data.Order.ClassesExtra",
        "Init.Data.Order.FactoriesExtra",
        "Init.Data.Order.LemmasExtra",
        "Init.Data.Order.PackageFactories"
      ],
      "approximate_function_count": 120,
      "categories": [
        "core_comparison",
        "type_specific_comparison",
        "lawfulness_properties",
        "order_relations",
        "package_factories"
      ]
    },
    "Std": {
      "modules": [
        "Std.Data.Internal.Cut",
        "Std.Data.DTreeMap.Internal.Ordered",
        "Std.Data.DTreeMap.Internal.Model",
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.Lemmas"
      ],
      "approximate_function_count": 80,
      "categories": [
        "internal_cut_operations",
        "dtreemap_ordering",
        "dtreemap_operations"
      ]
    }
  },
  "usage_patterns": [
    {
      "pattern": "basic_comparison",
      "example": "compare 5 10",
      "result": "Ordering.lt",
      "use_case": "Compare two values of the same type"
    },
    {
      "pattern": "comparison_by_function",
      "example": "compareOn (·.length) \"hello\" \"world\"",
      "result": "Ordering.eq",
      "use_case": "Compare values by a derived property"
    },
    {
      "pattern": "lexicographic_comparison",
      "example": "List.compareLex compare [1, 2, 3] [1, 2, 4]",
      "result": "Ordering.lt",
      "use_case": "Compare lists element-by-element"
    },
    {
      "pattern": "check_less_or_equal",
      "example": "(compare a b).isLE",
      "use_case": "Check if a ≤ b using comparison"
    },
    {
      "pattern": "check_greater_or_equal",
      "example": "(compare a b).isGE",
      "use_case": "Check if a ≥ b using comparison"
    }
  ],
  "recommendations": {
    "general_use": [
      "Use Ord.compare for comparing values of types with an Ord instance",
      "Use compareOn when comparing by a derived property",
      "Use compareLex for lexicographic comparison with tiebreaker",
      "Use type-specific comparisons (Nat.compare, Int.compare, etc.) when working with specific types"
    ],
    "for_proofs": [
      "Leverage comparison theorems like compare_eq_eq, compare_eq_lt, compare_eq_gt",
      "Use lawfulness properties (LawfulEqOrd, LawfulBEqOrd) to relate comparison to equality",
      "Use reflexivity, transitivity, and orientation properties for reasoning about comparisons",
      "Use isLE_compare and isGE_compare to relate comparison to order relations"
    ],
    "for_data_structures": [
      "Use compareLex variants for List, Array, Vector comparisons",
      "Leverage DTreeMap comparison lemmas when working with ordered maps",
      "Use comparison invariants to maintain ordered data structure properties"
    ]
  },
  "related_searches": [
    {
      "pattern": "\"Ordering\"",
      "description": "Find functions working with the Ordering type"
    },
    {
      "pattern": "\"_ < _\"",
      "description": "Find theorems about less-than relations"
    },
    {
      "pattern": "\"_ = _\"",
      "description": "Find equality-related functions"
    },
    {
      "pattern": "\"Ord\"",
      "description": "Find Ord instances and related functions"
    },
    {
      "pattern": "\"LawfulOrd\"",
      "description": "Find lawfulness properties for ordered types"
    },
    {
      "pattern": "\"Lex\"",
      "description": "Find lexicographic ordering functions"
    },
    {
      "pattern": "\"swap\"",
      "description": "Find functions for swapping comparison results"
    }
  ],
  "statistics": {
    "total_matches": 546,
    "matches_shown": 200,
    "primary_libraries": ["Init", "Std"],
    "key_modules": 15,
    "function_categories": 10,
    "core_functions": 11,
    "type_specific_types": 5,
    "lawfulness_theorems": 20,
    "dtreemap_internal_functions": 60
  }
}
