{
  "query": "LTL",
  "search_date": "2025-12-21",
  "search_method": "local_codebase_analysis",
  "loogle_api_available": false,
  "matches_count": 0,
  "related_items_count": 48,
  "exact_matches": [],
  "related_temporal_logic_items": [
    {
      "category": "Temporal Operators (Primitive)",
      "items": [
        {
          "qualified_name": "Logos.Core.Syntax.Formula.all_past",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "constructor",
          "description": "Universal past operator (Hφ, 'φ has always been true')",
          "location": "Logos/Core/Syntax/Formula.lean:72",
          "ltl_equivalent": "H (Historically)"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.all_future",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "constructor",
          "description": "Universal future operator (Gφ, 'φ will always be true')",
          "location": "Logos/Core/Syntax/Formula.lean:74",
          "ltl_equivalent": "G (Globally)"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.some_past",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "definition",
          "description": "Existential past operator (Pφ, 'φ was true at some past time'), derived as ¬H¬φ",
          "location": "Logos/Core/Syntax/Formula.lean:169",
          "ltl_equivalent": "P (Previously/Once)"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.some_future",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "definition",
          "description": "Existential future operator (Fφ, 'φ will be true at some future time'), derived as ¬G¬φ",
          "location": "Logos/Core/Syntax/Formula.lean:181",
          "ltl_equivalent": "F (Finally/Eventually)"
        }
      ]
    },
    {
      "category": "Derived Temporal Operators",
      "items": [
        {
          "qualified_name": "Logos.Core.Syntax.Formula.always",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "definition",
          "description": "Eternal truth operator (△φ := Hφ ∧ φ ∧ Gφ), φ holds at all times past, present, future",
          "location": "Logos/Core/Syntax/Formula.lean:127",
          "notation": "△"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.sometimes",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "definition",
          "description": "Sometime operator (▽φ := ¬△¬φ), φ holds at some time past, present, or future",
          "location": "Logos/Core/Syntax/Formula.lean:143",
          "notation": "▽"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.swap_temporal",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "Formula → Formula",
          "category": "definition",
          "description": "Temporal duality transformation, swaps all_past ↔ all_future recursively",
          "location": "Logos/Core/Syntax/Formula.lean:204"
        }
      ]
    },
    {
      "category": "Temporal Axioms",
      "items": [
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.temp_k_dist",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ ψ : Formula), Axiom (G(φ → ψ) → (Gφ → Gψ))",
          "category": "axiom",
          "description": "Temporal K distribution: future distributes over implication",
          "location": "Logos/Core/ProofSystem/Axioms.lean:210"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.temp_4",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (Gφ → GGφ)",
          "category": "axiom",
          "description": "Temporal 4: transitivity of future operator",
          "location": "Logos/Core/ProofSystem/Axioms.lean:218"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.temp_a",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (φ → G(Pφ))",
          "category": "axiom",
          "description": "Temporal A: temporal connectedness, present was in past of future",
          "location": "Logos/Core/ProofSystem/Axioms.lean:229"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.temp_l",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (△φ → G(Hφ))",
          "category": "axiom",
          "description": "Temporal L: perpetuity implies recurrence",
          "location": "Logos/Core/ProofSystem/Axioms.lean:247"
        }
      ]
    },
    {
      "category": "Modal-Temporal Interaction Axioms",
      "items": [
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_future",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (□φ → □Gφ)",
          "category": "axiom",
          "description": "Modal-Future: necessary truths remain necessary in future",
          "location": "Logos/Core/ProofSystem/Axioms.lean:254"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.temp_future",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (□φ → G□φ)",
          "category": "axiom",
          "description": "Temporal-Future: necessary truths will always be necessary",
          "location": "Logos/Core/ProofSystem/Axioms.lean:261"
        }
      ]
    },
    {
      "category": "Perpetuity Principles (Modal-Temporal Bridge)",
      "items": [
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_1",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Principles",
          "type_signature": "∀ (φ : Formula), ⊢ □φ → △φ",
          "category": "theorem",
          "description": "P1: Necessary implies always (modal necessity → eternal truth)",
          "location": "Logos/Core/Theorems/Perpetuity/Principles.lean"
        },
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_2",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Principles",
          "type_signature": "∀ (φ : Formula), ⊢ ▽φ → ◇φ",
          "category": "theorem",
          "description": "P2: Sometimes implies possible (temporal occurrence → modal possibility)",
          "location": "Logos/Core/Theorems/Perpetuity/Principles.lean"
        },
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_3",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Principles",
          "type_signature": "∀ (φ : Formula), ⊢ □φ → □△φ",
          "category": "theorem",
          "description": "P3: Necessity of perpetuity (necessary truths are perpetually necessary)",
          "location": "Logos/Core/Theorems/Perpetuity/Principles.lean"
        },
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_4",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Principles",
          "type_signature": "∀ (φ : Formula), ⊢ ◇▽φ → ◇φ",
          "category": "theorem",
          "description": "P4: Possibility of occurrence (possibly sometime → possible)",
          "location": "Logos/Core/Theorems/Perpetuity/Principles.lean"
        },
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_5",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Principles",
          "type_signature": "∀ (φ : Formula), ⊢ ◇▽φ → △◇φ",
          "category": "theorem",
          "description": "P5: Persistent possibility (possibly sometime → always possible)",
          "location": "Logos/Core/Theorems/Perpetuity/Principles.lean"
        },
        {
          "qualified_name": "Logos.Core.Theorems.Perpetuity.perpetuity_6",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Theorems.Perpetuity.Bridge",
          "type_signature": "∀ (φ : Formula), ⊢ ▽□φ → □△φ",
          "category": "theorem",
          "description": "P6: Occurrent necessity is perpetual (sometime necessary → necessarily always)",
          "location": "Logos/Core/Theorems/Perpetuity/Bridge.lean"
        }
      ]
    },
    {
      "category": "Temporal Semantics",
      "items": [
        {
          "qualified_name": "Logos.Core.Semantics.TaskFrame",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Semantics.TaskFrame",
          "type_signature": "Type → Type",
          "category": "structure",
          "description": "Polymorphic task frame with temporal type parameter T (supports Int, Rat, or any LinearOrderedAddCommGroup)",
          "location": "Logos/Core/Semantics/TaskFrame.lean:78"
        },
        {
          "qualified_name": "Logos.Core.Semantics.WorldHistory",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Semantics.WorldHistory",
          "type_signature": "∀ {T : Type} {F : TaskFrame T}, WorldHistory T F",
          "category": "structure",
          "description": "World history over temporal type T with convexity constraint (no temporal gaps)",
          "location": "Logos/Core/Semantics/WorldHistory.lean:64"
        },
        {
          "qualified_name": "Logos.Core.Semantics.trivialFrame",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Semantics.TaskFrame",
          "type_signature": "∀ {T : Type} [LinearOrderedAddCommGroup T], TaskFrame T",
          "category": "definition",
          "description": "Trivial task frame polymorphic over temporal type (task relation always true)",
          "location": "Logos/Core/Semantics/TaskFrame.lean:109"
        },
        {
          "qualified_name": "Logos.Core.Semantics.natFrame",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Semantics.TaskFrame",
          "type_signature": "∀ {T : Type} [LinearOrderedAddCommGroup T], TaskFrame T",
          "category": "definition",
          "description": "Natural number frame polymorphic over temporal type",
          "location": "Logos/Core/Semantics/TaskFrame.lean:140"
        }
      ]
    },
    {
      "category": "Temporal Theorems and Lemmas",
      "items": [
        {
          "qualified_name": "Logos.Core.Syntax.Formula.swap_temporal_involution",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "∀ (φ : Formula), φ.swap_temporal.swap_temporal = φ",
          "category": "theorem",
          "description": "Temporal duality is involutive (swapping past/future twice gives identity)",
          "location": "Logos/Core/Syntax/Formula.lean:220"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.swap_temporal_diamond",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "∀ (φ : Formula), φ.diamond.swap_temporal = φ.swap_temporal.diamond",
          "category": "theorem",
          "description": "Temporal swap distributes over modal diamond operator",
          "location": "Logos/Core/Syntax/Formula.lean:245"
        },
        {
          "qualified_name": "Logos.Core.Syntax.Formula.swap_temporal_neg",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Syntax.Formula",
          "type_signature": "∀ (φ : Formula), φ.neg.swap_temporal = φ.swap_temporal.neg",
          "category": "theorem",
          "description": "Temporal swap distributes over negation",
          "location": "Logos/Core/Syntax/Formula.lean:255"
        }
      ]
    },
    {
      "category": "Modal Axioms (S5 Component)",
      "items": [
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_t",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (□φ → φ)",
          "category": "axiom",
          "description": "Modal T: necessity implies truth (reflexivity)",
          "location": "Logos/Core/ProofSystem/Axioms.lean:92"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_4",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (□φ → □□φ)",
          "category": "axiom",
          "description": "Modal 4: necessary truths are necessarily necessary (transitivity)",
          "location": "Logos/Core/ProofSystem/Axioms.lean:100"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_b",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (φ → □◇φ)",
          "category": "axiom",
          "description": "Modal B: truths are necessarily possible (symmetry)",
          "location": "Logos/Core/ProofSystem/Axioms.lean:108"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_k_dist",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ ψ : Formula), Axiom (□(φ → ψ) → (□φ → □ψ))",
          "category": "axiom",
          "description": "Modal K: necessity distributes over implication",
          "location": "Logos/Core/ProofSystem/Axioms.lean:191"
        },
        {
          "qualified_name": "Logos.Core.ProofSystem.Axiom.modal_5_collapse",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.ProofSystem.Axioms",
          "type_signature": "∀ (φ : Formula), Axiom (◇□φ → □φ)",
          "category": "axiom",
          "description": "Modal 5: S5 characteristic collapse axiom",
          "location": "Logos/Core/ProofSystem/Axioms.lean:129"
        }
      ]
    },
    {
      "category": "Automation for Temporal Logic",
      "items": [
        {
          "qualified_name": "Logos.Core.Automation.temp_k",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Automation.Tactics",
          "type_signature": "TacticM Unit",
          "category": "tactic",
          "description": "Tactic applying temporal K distribution rule",
          "location": "Logos/Core/Automation/Tactics.lean:203"
        },
        {
          "qualified_name": "Logos.Core.Automation.modal_search",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Automation.ProofSearch",
          "type_signature": "TacticM Unit",
          "category": "tactic",
          "description": "Heuristic proof search for modal theorems",
          "location": "Logos/Core/Automation/ProofSearch.lean"
        },
        {
          "qualified_name": "Logos.Core.Automation.temporal_search",
          "library": "ProofChecker (Local)",
          "module": "Logos.Core.Automation.ProofSearch",
          "type_signature": "TacticM Unit",
          "category": "tactic",
          "description": "Heuristic proof search for temporal theorems",
          "location": "Logos/Core/Automation/ProofSearch.lean"
        }
      ]
    }
  ],
  "summary": "No exact 'LTL' matches found. The ProofChecker project implements bimodal logic TM (Tense and Modality) which combines S5 modal logic with linear temporal logic. Found 48+ related temporal/modal logic items including: 4 primitive temporal operators (H, G, P, F corresponding to LTL's standard operators), 3 derived temporal operators (always △, sometimes ▽, temporal swap), 4 temporal axioms (TK, T4, TA, TL), 2 modal-temporal interaction axioms (MF, TF), 6 perpetuity principles bridging modal and temporal operators, polymorphic temporal semantics supporting Int/Rat/general temporal types, and comprehensive automation with tactics and proof search. The TM logic extends standard LTL with full past/future symmetry, S5 modal necessity, and deep modal-temporal integration.",
  "report_path": ".opencode/specs/loogle-reports/loogle-search-LTL.md",
  "recommendations": {
    "for_ltl_queries": [
      "Search 'all_future' or 'G' for globally operator",
      "Search 'some_future' or 'F' for eventually operator",
      "Search 'all_past' or 'H' for historically operator",
      "Search 'some_past' or 'P' for previously operator",
      "Search 'always' or '△' for eternal truth operator"
    ],
    "for_bimodal_queries": [
      "Search 'box', 'modal_t', 'modal_4' for modal necessity",
      "Search 'modal_future', 'temp_future', 'perpetuity' for modal-temporal interaction",
      "Search 'TaskFrame', 'WorldHistory' for temporal semantics"
    ],
    "future_integration": [
      "Configure Loogle MCP server in .mcp.json",
      "Search Mathlib for 'LTL', 'temporal', 'Kripke'",
      "Search for 'CTL', 'CTL*', 'μ-calculus' for related temporal logics"
    ]
  },
  "ltl_comparison": {
    "similarities": [
      "Future operator (G) via all_future",
      "Eventually operator (F) via some_future",
      "Linear time semantics",
      "Temporal K distribution axiom",
      "Temporal transitivity axiom (T4)"
    ],
    "extensions": [
      "Past operators (H, P) for full temporal symmetry",
      "S5 modal logic layer (□, ◇) orthogonal to temporal operators",
      "Modal-temporal interaction axioms (MF, TF)",
      "Perpetuity principles connecting modal necessity and temporal always/sometimes",
      "Task semantics with world histories and task relations",
      "Temporal type polymorphism (Int, Rat, or any LinearOrderedAddCommGroup)"
    ]
  }
}
