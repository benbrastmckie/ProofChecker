{
  "type_pattern": "Nat → _ → Except _ _",
  "search_date": "2025-12-21",
  "matches_count": 27,
  "exact_matches_count": 6,
  "exact_matches": [
    {
      "name": "Lean.Json.getArrVal?",
      "type": "Lean.Json → ℕ → Except String Lean.Json",
      "library": "Lean core",
      "module": "Lean.Data.Json.Basic",
      "documentation": null,
      "use_case": "Extract a value from a JSON array at a given natural number index",
      "error_type": "String",
      "return_type": "Lean.Json"
    },
    {
      "name": "Lean.Json.parseTagged",
      "type": "(json : Lean.Json) (tag : String) (nFields : ℕ) (fieldNames? : Option (Array Lean.Name)) : Except String (Array Lean.Json)",
      "library": "Lean core",
      "module": "Lean.Data.Json.FromToJson.Basic",
      "documentation": "Parses a JSON-encoded `structure` or `inductive` constructor. Used mostly by `deriving FromJson`.",
      "use_case": "Parse tagged JSON structures with a specified number of fields",
      "error_type": "String",
      "return_type": "Array Lean.Json"
    },
    {
      "name": "Lean.Parser.addLeadingParser",
      "type": "(categories : Lean.Parser.ParserCategories) (catName declName : Lean.Name) (p : Lean.Parser.Parser) (prio : ℕ) : Except String Lean.Parser.ParserCategories",
      "library": "Lean core",
      "module": "Lean.Parser.Extension",
      "documentation": null,
      "use_case": "Add a leading parser to parser categories with specified priority",
      "error_type": "String",
      "return_type": "Lean.Parser.ParserCategories"
    },
    {
      "name": "Lean.Parser.addTrailingParser",
      "type": "(categories : Lean.Parser.ParserCategories) (catName declName : Lean.Name) (p : Lean.Parser.TrailingParser) (prio : ℕ) : Except String Lean.Parser.ParserCategories",
      "library": "Lean core",
      "module": "Lean.Parser.Extension",
      "documentation": null,
      "use_case": "Add a trailing parser to parser categories with specified priority",
      "error_type": "String",
      "return_type": "Lean.Parser.ParserCategories"
    },
    {
      "name": "Lean.Parser.addParser",
      "type": "(categories : Lean.Parser.ParserCategories) (catName declName : Lean.Name) (leading : Bool) (p : Lean.Parser.Parser) (prio : ℕ) : Except String Lean.Parser.ParserCategories",
      "library": "Lean core",
      "module": "Lean.Parser.Extension",
      "documentation": null,
      "use_case": "Add a parser (leading or trailing) to parser categories with specified priority",
      "error_type": "String",
      "return_type": "Lean.Parser.ParserCategories"
    },
    {
      "name": "Lean.Elab.Tactic.BVDecide.LRAT.trim.M.findInitialId",
      "type": "(proof : Array Std.Tactic.BVDecide.LRAT.IntAction) (curr : ℕ := 0) : Except String ℕ",
      "library": "Lean core",
      "module": "Lean.Elab.Tactic.BVDecide.LRAT.Trim",
      "documentation": null,
      "use_case": "Find the initial ID in an LRAT proof, starting from a given natural number",
      "error_type": "String",
      "return_type": "ℕ"
    }
  ],
  "partial_matches": [
    {
      "name": "Lean.Json.getNat?",
      "type": "Lean.Json → Except String ℕ",
      "library": "Lean core",
      "module": "Lean.Data.Json.Basic",
      "documentation": null,
      "similarity": "Returns Nat from JSON, no Nat input parameter"
    },
    {
      "name": "Lean.bignumFromJson?",
      "type": "(j : Lean.Json) : Except String ℕ",
      "library": "Lean core",
      "module": "Lean.Data.Json.FromToJson.Basic",
      "documentation": "Note that `USize`s and `UInt64`s are stored as strings because JavaScript cannot represent 64-bit numbers.",
      "similarity": "Returns Nat from JSON, no Nat input parameter"
    },
    {
      "name": "Lean.Parser.getParserPriority",
      "type": "(args : Lean.Syntax) : Except String ℕ",
      "library": "Lean core",
      "module": "Lean.Parser.Extension",
      "documentation": null,
      "similarity": "Returns Nat via Except, no Nat input parameter"
    },
    {
      "name": "Lean.ErrorExplanation.processDoc",
      "type": "(doc : String) : Except (ℕ × String) Unit",
      "library": "Lean core",
      "module": "Lean.ErrorExplanation",
      "documentation": "Validates that the given error explanation has the expected structure. If an error is found, it is represented as a pair `(lineNumber, errorMessage)` where `lineNumber` gives the 0-based offset from the first line of `doc` at which the error occurs.",
      "similarity": "Uses Nat in error type, not as parameter"
    },
    {
      "name": "Lean.Elab.Tactic.BVDecide.LRAT.trim.M.findEmptyId",
      "type": "(proof : Array Std.Tactic.BVDecide.LRAT.IntAction) : Except String ℕ",
      "library": "Lean core",
      "module": "Lean.Elab.Tactic.BVDecide.LRAT.Trim",
      "documentation": null,
      "similarity": "Returns Nat via Except, no Nat input parameter"
    }
  ],
  "related_functions": [
    {
      "name": "Lean.Elab.Tactic.BVDecide.Frontend.runExternal",
      "type": "(cnf : Std.Sat.CNF ℕ) (solver lratPath : System.FilePath) (trimProofs : Bool) (timeout : ℕ) (binaryProofs : Bool) : Lean.CoreM (Except (Array (Bool × ℕ)) Lean.Elab.Tactic.BVDecide.Frontend.LratCert)",
      "library": "Lean core",
      "module": "Lean.Elab.Tactic.BVDecide.Frontend.LRAT",
      "documentation": "Run an external SAT solver on the `CNF` to obtain an LRAT proof. This will obtain an `LratCert` if the formula is UNSAT and throw errors otherwise.",
      "relation": "Uses Nat in CNF type and timeout parameter, returns Except in monad"
    },
    {
      "name": "Lean.Elab.Tactic.BVDecide.Frontend.lratBitblaster",
      "type": "(goal : Lean.MVarId) (ctx : Lean.Elab.Tactic.BVDecide.Frontend.TacticContext) (reflectionResult : Lean.Elab.Tactic.BVDecide.Frontend.ReflectionResult) (atomsAssignment : Std.HashMap ℕ (ℕ × Lean.Expr × Bool)) : Lean.MetaM (Except Lean.Elab.Tactic.BVDecide.Frontend.CounterExample Lean.Elab.Tactic.BVDecide.Frontend.UnsatProver.Result)",
      "library": "Lean core",
      "module": "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide",
      "documentation": null,
      "relation": "Uses Nat in HashMap keys and values, returns Except in monad"
    },
    {
      "name": "Std.Broadcast.send",
      "type": "{α : Type} (ch : Std.Broadcast α) (v : α) : BaseIO (Task (Except IO.Error ℕ))",
      "library": "Std",
      "module": "Std.Sync.Broadcast",
      "documentation": "Send a value through the broadcast channel, returning a task that will resolve once the transmission could be completed.",
      "relation": "Returns Nat via Except in Task monad"
    },
    {
      "name": "Mathlib.Tactic.Sat.buildProofStep",
      "type": "(db : Std.HashMap ℕ Mathlib.Tactic.Sat.Clause) (ns pf : Array ℤ) (ctx clause : Lean.Expr) : Except String Lean.Expr",
      "library": "Mathlib",
      "module": "Mathlib.Tactic.Sat.FromLRAT",
      "documentation": "Construct an individual proof step `⊢ ctx.proof c`.",
      "relation": "Uses Nat in HashMap keys, returns Except"
    },
    {
      "name": "Loogle.Find.find",
      "type": "(index : Loogle.Find.Index) (args : Lean.TSyntax `Loogle.Find.find_filters) (maxShown : ℕ := 200) : Lean.Elab.TermElabM (Except Loogle.Find.Failure Loogle.Find.Result)",
      "library": "Loogle",
      "module": "Loogle.Find",
      "documentation": "The core of the `#find` tactic with all parsing/printing factored out, for programmatic use (e.g. the loogle CLI). It also does not use the implicit global Index, but rather expects one as an argument.",
      "relation": "Uses Nat for maxShown parameter, returns Except in monad"
    }
  ],
  "size_spec_functions": [
    {
      "name": "Except.ctorElimType",
      "type": "{ε : Type u} {α : Type v} {motive : Except ε α → Sort u_1} (ctorIdx : ℕ) : Sort (max 1 (imax (u + 1) u_1) (imax (v + 1) u_1))",
      "module": "Init.Prelude",
      "library": "Lean Init"
    },
    {
      "name": "Except.error.sizeOf_spec",
      "type": "{ε : Type u} {α : Type v} [SizeOf ε] [SizeOf α] (a✝ : ε) : sizeOf (Except.error a✝) = 1 + sizeOf a✝",
      "module": "Init.SizeOf",
      "library": "Lean Init"
    },
    {
      "name": "Except.ok.sizeOf_spec",
      "type": "{ε : Type u} {α : Type v} [SizeOf ε] [SizeOf α] (a✝ : α) : sizeOf (Except.ok a✝) = 1 + sizeOf a✝",
      "module": "Init.SizeOf",
      "library": "Lean Init"
    },
    {
      "name": "IO.AsyncList.delayed.sizeOf_spec",
      "type": "{ε : Type u} {α : Type v} [SizeOf ε] [SizeOf α] (tl : Lean.Server.ServerTask (Except ε (IO.AsyncList ε α))) : sizeOf (IO.AsyncList.delayed tl) = 1 + sizeOf tl",
      "module": "Lean.Server.AsyncList",
      "library": "Lean core"
    },
    {
      "name": "Lean.Server.RequestHandler.mk.sizeOf_spec",
      "module": "Lean.Server.Requests",
      "library": "Lean core"
    },
    {
      "name": "Lean.Server.StatefulRequestHandler.mk.sizeOf_spec",
      "module": "Lean.Server.Requests",
      "library": "Lean core"
    },
    {
      "name": "Lean.Server.FileWorker.PendingRequest.mk.sizeOf_spec",
      "module": "Lean.Server.FileWorker",
      "library": "Lean core"
    },
    {
      "name": "Lean.Server.FileWorker.WorkerState.mk.sizeOf_spec",
      "module": "Lean.Server.FileWorker",
      "library": "Lean core"
    }
  ],
  "testing_library_functions": [
    {
      "name": "Plausible.instMonadLiftStateIOGen",
      "type": "MonadLift (ReaderT (ULift.{0, 0} ℕ) (Except Plausible.GenError)) IO",
      "module": "Plausible.Gen",
      "library": "Plausible"
    },
    {
      "name": "Plausible.instMonadLiftGen",
      "type": "{m : Type u_1 → Type u_2} [MonadLiftT m (ReaderT (ULift.{u_1, 0} ℕ) (Except Plausible.GenError))] : MonadLiftT (Plausible.RandGT StdGen m) Plausible.Gen",
      "module": "Plausible.Gen",
      "library": "Plausible"
    }
  ],
  "proofwidgets_functions": [
    {
      "name": "ProofWidgets.CancellableTask.mk.sizeOf_spec",
      "type": "(task : Task (Except Lean.Server.RequestError (ProofWidgets.LazyEncodable Lean.Json))) (cancel : IO Unit) : sizeOf { task := task, cancel := cancel } = 1 + sizeOf task",
      "module": "ProofWidgets.Cancellable",
      "library": "ProofWidgets"
    }
  ],
  "statistics": {
    "total_functions": 27,
    "exact_matches": 6,
    "partial_matches": 5,
    "related_functions": 5,
    "size_spec_functions": 8,
    "testing_functions": 2,
    "proofwidgets_functions": 1,
    "library_distribution": {
      "Lean_core": 20,
      "Std": 1,
      "Mathlib": 1,
      "Plausible": 2,
      "ProofWidgets": 1,
      "Loogle": 1
    },
    "error_type_distribution": {
      "String": 13,
      "IO.Error": 3,
      "Nat_x_String": 1,
      "Array_Bool_x_Nat": 1,
      "CounterExample": 1,
      "GenError": 2,
      "RequestError": 2,
      "Failure": 1,
      "Type_parameters": 3
    },
    "use_case_distribution": {
      "JSON_operations": 3,
      "Parser_extensions": 4,
      "BVDecide_LRAT": 4,
      "Server_LSP": 5,
      "Size_specifications": 8,
      "Testing": 2,
      "Error_processing": 1,
      "SAT_solving": 1,
      "Search": 1,
      "Widgets": 1
    }
  },
  "search_queries": [
    {
      "query": "Nat → _ → Except _ _",
      "status": "success",
      "results": 6
    },
    {
      "query": "Nat → α → Except ε α",
      "status": "error",
      "error": "Unknown identifier α",
      "suggestions": 10
    },
    {
      "query": "Nat → _ → Except",
      "status": "error",
      "error": "type expected - Except requires two type parameters"
    },
    {
      "query": "Nat, Except",
      "status": "success",
      "results": 27
    }
  ],
  "report_path": ".opencode/specs/loogle-search-project/specialist-reports/loogle-nat-except-pattern.md",
  "summary": "Found 27 total functions involving Nat and Except types, with 6 exact matches for the pattern 'Nat → _ → Except _ _'. Primary use cases are JSON parsing (3), parser extensions (4), and LRAT/BVDecide operations (4). Most functions use String as error type. Functions are concentrated in Lean core libraries (74%), with additional matches in Mathlib, Std, Plausible, ProofWidgets, and Loogle."
}
