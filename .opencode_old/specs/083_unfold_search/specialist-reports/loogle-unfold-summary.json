{
  "type_pattern": "unfold",
  "search_type": "name_pattern",
  "date": "2025-12-20",
  "matches_count": 297,
  "displayed_count": 200,
  "report_path": ".opencode/specs/083_unfold_search/specialist-reports/loogle-unfold-complete.md",
  "exact_matches": [
    {
      "name": "Lean.Meta.unfold",
      "type": "Lean.Expr → Lean.Name → Lean.MetaM (Option Lean.Expr)",
      "library": "Lean Core",
      "module": "Lean.Meta.WHNF",
      "category": "function",
      "description": "Core unfolding function at meta level"
    },
    {
      "name": "Lean.Meta.unfoldDefinition",
      "type": "Lean.Expr → Lean.MetaM Lean.Expr",
      "library": "Lean Core",
      "module": "Lean.Meta.WHNF",
      "category": "function",
      "description": "Unfolds a definition to its body"
    },
    {
      "name": "Lean.Meta.unfoldDefinition?",
      "type": "Lean.Expr → Lean.MetaM (Option Lean.Expr)",
      "library": "Lean Core",
      "module": "Lean.Meta.WHNF",
      "category": "function",
      "description": "Optional unfolding with fallback"
    },
    {
      "name": "Lean.Meta.canUnfold",
      "type": "Lean.Expr → Lean.Name → Lean.MetaM Bool",
      "library": "Lean Core",
      "module": "Lean.Meta.WHNF",
      "category": "function",
      "description": "Check if a constant can be unfolded"
    },
    {
      "name": "Lean.Parser.Tactic.unfold",
      "type": "Lean.Parser.Parser",
      "library": "Lean Core",
      "module": "Lean.Parser.Tactic",
      "category": "tactic",
      "description": "Main unfold tactic parser"
    },
    {
      "name": "Lean.Meta.smartUnfolding",
      "type": "Lean.Option Bool",
      "library": "Lean Core",
      "module": "Lean.Meta.WHNF",
      "category": "option",
      "description": "Option to enable/disable smart unfolding"
    },
    {
      "name": "Lean.Meta.SimpTheorems.addDeclToUnfold",
      "type": "Lean.Meta.SimpTheorems → Lean.Name → Bool → Lean.MetaM Lean.Meta.SimpTheorems",
      "library": "Lean Core",
      "module": "Lean.Meta.Tactic.Simp.SimpTheorems",
      "category": "function",
      "description": "Add declaration to unfold set in simp"
    },
    {
      "name": "Lean.Meta.recordUnfold",
      "type": "Lean.Name → Lean.MetaM Unit",
      "library": "Lean Core",
      "module": "Lean.Meta.Basic",
      "category": "function",
      "description": "Record unfolding in diagnostics"
    },
    {
      "name": "Lean.Meta.getUnfoldEqnFor?",
      "type": "Lean.Name → Bool → Lean.MetaM (Option Lean.Meta.UnfoldEqnInfo)",
      "library": "Lean Core",
      "module": "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core",
      "category": "function",
      "description": "Get unfold equation for declaration"
    },
    {
      "name": "Lean.Elab.WF.mkUnfoldEq",
      "type": "Complex elaboration type",
      "library": "Lean Core",
      "module": "Lean.Elab.PreDefinition.WF",
      "category": "function",
      "description": "Make unfold equation for well-founded recursion"
    }
  ],
  "categories": {
    "core_meta_functions": {
      "count": 30,
      "examples": ["Lean.Meta.unfold", "Lean.Meta.unfoldDefinition", "Lean.Meta.canUnfold"]
    },
    "smart_unfolding": {
      "count": 10,
      "examples": ["Lean.Meta.smartUnfolding", "Lean.Meta.smartUnfoldingReduce?", "Lean.Meta.markSmartUnfoldingMatch"]
    },
    "diagnostics": {
      "count": 10,
      "examples": ["Lean.Meta.recordUnfold", "Lean.Meta.Diagnostics.unfoldCounter", "Lean.Meta.mkDiagSummaryForUnfolded"]
    },
    "tactic_infrastructure": {
      "count": 10,
      "examples": ["Lean.Parser.Tactic.unfold", "Lean.Parser.Tactic.simpAutoUnfold", "Lean.Elab.Tactic.evalWithUnfoldingAll"]
    },
    "simp_integration": {
      "count": 25,
      "examples": ["Lean.Meta.SimpTheorems.addDeclToUnfold", "Lean.Meta.Simp.Config.autoUnfold", "Lean.Meta.SimpEntry.toUnfold"]
    },
    "equation_generation": {
      "count": 10,
      "examples": ["Lean.Meta.getUnfoldEqnFor?", "Lean.Elab.WF.mkUnfoldEq", "Lean.Meta.unfoldThmSuffix"]
    },
    "auto_generated_lemmas": {
      "count": 200,
      "patterns": ["*.induct_unfolding", "*.fun_cases_unfolding"]
    },
    "data_structures": {
      "count": 20,
      "examples": ["Batteries.RBNode.balance1.induct_unfolding", "Std.DTreeMap.Internal.Impl.ins.induct_unfolding"]
    },
    "grind_solver": {
      "count": 15,
      "examples": ["Lean.Grind.CommRing.Poly.normM.induct_unfolding", "Lean.Grind.AC.main.induct_unfolding"]
    },
    "aesop": {
      "count": 4,
      "examples": ["Aesop.BuilderName.unfold", "Aesop.RuleBuilder.unfold"]
    }
  },
  "key_findings": {
    "no_bounded_unfolding": {
      "finding": "No explicit bounded unfolding functions found",
      "details": "No functions like unfoldBounded, unfoldN, or unfoldWithLimit exist",
      "implication": "Termination relies on structural recursion and implicit kernel limits"
    },
    "smart_unfolding": {
      "finding": "Sophisticated smart unfolding optimization",
      "details": "Avoids redundant unfolding in match expressions",
      "benefit": "Performance optimization for match-heavy code"
    },
    "diagnostic_tracking": {
      "finding": "Comprehensive diagnostic infrastructure",
      "details": "Tracks unfold operations at both kernel and meta levels",
      "usage": "Performance profiling and analysis"
    },
    "simp_integration": {
      "finding": "Deep integration with simplifier",
      "details": "Multiple configuration options and unfold theorem management",
      "flexibility": "Fine-grained control over unfolding behavior"
    },
    "auto_generated": {
      "finding": "Extensive auto-generated lemmas",
      "details": "induct_unfolding and fun_cases_unfolding for recursive functions",
      "purpose": "Well-founded induction and case analysis principles"
    }
  },
  "termination_mechanisms": [
    {
      "mechanism": "Structural recursion on syntax trees",
      "description": "Most meta-level unfold functions recurse on Lean.Expr structure",
      "guarantee": "Well-founded recursion on expression size"
    },
    {
      "mechanism": "Single-step unfolding",
      "description": "Functions like unfoldDefinition perform single expansion",
      "guarantee": "No recursion, immediate termination"
    },
    {
      "mechanism": "Well-founded recursion",
      "description": "Auto-generated induct_unfolding lemmas",
      "guarantee": "Termination proven by decreasing measure"
    },
    {
      "mechanism": "Kernel-level limits",
      "description": "Implicit reduction limits in the kernel",
      "guarantee": "Prevents infinite unfolding"
    },
    {
      "mechanism": "Smart unfolding optimization",
      "description": "Avoids redundant unfolding in match expressions",
      "guarantee": "Reduces total unfold operations"
    }
  ],
  "library_distribution": {
    "lean_core_init": "40%",
    "lean_meta": "25%",
    "lean_elab": "10%",
    "auto_generated": "20%",
    "batteries_std": "3%",
    "mathlib": "1%",
    "aesop": "1%"
  },
  "recommendations": {
    "for_bounded_unfolding": [
      "Implement custom depth-limited unfold function",
      "Build on existing Lean.Meta.unfold infrastructure",
      "Add explicit depth/count tracking parameter",
      "Use withCanUnfoldPred for control"
    ],
    "using_existing": [
      "Use withCanUnfoldPred to control which definitions unfold",
      "Mark definitions as irreducible to prevent unfolding",
      "Configure autoUnfold and unfoldPartialApp in simp",
      "Enable smart unfolding for performance in match-heavy code"
    ],
    "performance_monitoring": [
      "Use recordUnfold to track unfold operations",
      "Use mkDiagSummaryForUnfolded to analyze patterns",
      "Use unfoldCounter to count unfolds per definition"
    ]
  },
  "summary": "Comprehensive search of 297 'unfold' declarations reveals sophisticated unfolding infrastructure with smart optimization, deep simp integration, and extensive diagnostic tracking. Key finding: NO explicit bounded unfolding functions exist - termination relies on structural recursion, well-founded principles, and implicit kernel limits. Smart unfolding provides performance optimization. Auto-generated induct_unfolding lemmas support recursive function reasoning. For bounded unfolding, custom implementation needed building on Lean.Meta.unfold with explicit depth tracking."
}
